Capitulo 1. INTRODUCCION 
Comandos para cofigurar django:
En el directorio de trabajo ejecutar:
-> django­admin startproject <nombre del sitio>

Estos archivos son los siguientes:
-> misitio/: El directorio de trabajo externo misitio/, es solo un contenedor, es
decir una carpeta que contiene nuestro proyecto. Por lo que se le puede
cambiar el nombre en cualquier momento sin afectar el proyecto en sí.

-> manage.py: Una utilidad de línea de comandos que te permite interactuar
con un proyecto Django de varias formas. Usa manage.py help para ver lo que puede hacer. No deberías editar este archivo, ya que este es creado en el
directorio convenientemente para manejar el proyecto.

-> misitio/misitio/: El directorio interno misitio/ contiene el paquete Python
para tu proyecto. El nombre de este paquete Python se usara para importar
cualquier cosa dentro del. (Por ejemplo import misitio.settings).

-> __init__.py: Un archivo requerido para que Python trate el directorio misitio
como un paquete o como un grupo de módulos. Es un archivo vacio y
generalmente no necesitaras agregarle nada.

-> settings.py: Las opciones/configuraciones para nuestro proyecto Django.
Dale un vistazo, para que te des una idea de los tipos de configuraciones
disponibles y sus valores predefinidos.

-> urls.py: Declaración de las URLs para este proyecto de Django. Piensa que es
como una ‘‘tabla de contenidos’’ de tu sitio hecho con Django.

-> wsgi.py: El punto de entrada WSGI para el servidor Web, encargado de servir
nuestro proyecto. Para más detalles consulta el capítulo12

De forma predeterminada INSTALLED_APPS contiene todas las aplicaciones, que
vienen por defecto con Django:
-> django.contrib.admin -- La interfaz administrativa.
-> django.contrib.auth -- El sistema de autentificación.
-> django.contrib.contenttypes -- Un framework para tipos de contenidos.
-> django.contrib.sessions -- Un framework. para manejar sesiones
-> django.contrib.messages -- Un framework para manejar mensajes
-> django.contrib.staticfiles -- Un framework para manejar archivos estáticos.

-> python manage.py migrate # Crear la bd por defecto sqlite

-> python manage.py runserver # Arrancar el servidor de prueba de django

Capitulo 2. EMPEZANDO 
El algoritmo de trabajo de Django:

1. Se recibe una petición, por ejemplo a /hola/
2. Django determina la URLconf a usar, buscando la variable ROOT_URLCONF
en el archivo de configuraciones.
3. Django busca todos los patrones en la URLconf buscando la primera
coincidencia con /hola/.
4. Si encuentra uno que coincida, llama a la función vista asociada.
5. La función vista retorna una HttpResponse.
6. Django convierte el HttpResponse en una apropiada respuesta HTTP, la cual
convierte en una página Web.

Acoplamiento debil, permite la modularidad del codigo fuente en la web; se puede realizar
cambios en una funcion sin afectar el comportamiento de las otras. Para usar una misma vista en
varias llamdas solo se debe cambiar el nombre de la direccion. Ejemplo:
urlpatterns = [
path(hola/', hola),
path('fecha/', fecha_actual),
path('otrafecha/', fecha_actual),
]

Capitulo 3. LOS PRINCIPIOS BÁSICOS DE LAS PAGINAS WEB DINÁMICAS

Cómo procesa una petición Django: Detalles completos

En resumen esto es lo que pasa:

-> Cuando llega una petición HTTP desde el navegador, un manejador específico
a cada servidor construye la HttpRequest, para pasarla a los componentes y
manejar el flujo del procesamiento de la respuesta.
-> El manejador luego llama a cualquier middleware de Petición o Vista
disponible. Estos tipos de middleware son útiles para aumentar los objetos
HttpRequest así como también para proveer un manejo especial a
determinados tipos de peticiones. En el caso de que alguno de los mismos
retornara un HttpResponse la vista no es invocada.
-> Hasta a los mejores programadores se le escapan errores (bugs), pero el
middleware de excepción ayuda a aplastarlos. Si una función de vista lanza
una excepción, el control pasa al middleware de Excepción. Si este
middleware no retorna un HttpResponse, la excepción se vuelve a lanzar.
-> Sin embargo, no todo está perdido. Django incluye vistas por omisión para
respuestas amigables a errores 404 y 500.
-> Finalmente, el middleware de respuesta es bueno para el procesamiento
posterior a un HttpResponse justo antes de que se envíe al navegador o
haciendo una limpieza de recursos específicos a una petición

Capitulo 4. El SISTEMA DE PLANTILLAS

Sumerjámonos por un rato en el sistema de plantillas, para entender la forma en que
trabajan --por ahora no las integraremos en las vistas que creamos en el capítulo
anterior.
El objetivo será mostrar cómo trabaja el sistema de plantillas,
independientemente del resto de Django (Veámoslo de otra forma: normalmente
usaríamos el sistema de plantillas dentro de una vista, sin embargo lo que queremos
dejar muy en claro, es que el sistema de plantillas es solo una librería de código
Python, que se puede utilizar en cualquier parte, no solo en las vista de Django.)
Esta es la forma básica, en la que podemos usar el sistema de plantillas de Django
en código Python.
1. Crea un objeto Template pasándole el código en crudo de la plantilla como
una cadena.
2. Llama al método render() del objeto Template con un conjunto de variables (o
sea, el contexto). Este retorna una plantilla totalmente renderizada como una
cadena de caracteres, con todas las variables y etiquetas de bloque evaluadas
de acuerdo al contexto.

El sistema lanza una excepción TemplateSyntaxError por alguno de los siguientes
casos:
-> Bloques de etiquetas inválidos
-> Argumentos inválidos para una etiqueta válida
-> Filtros inválidos
-> Argumentos inválidos para filtros válidos
-> Sintaxis inválida de plantilla
-> Etiquetas de bloque sin cerrar (para etiquetas de bloque que requieran la
etiqueta de cierre).

Uso de renderizado:
# Mal
for nombre in ('Juan', 'Julia', 'Paty'):
t = Template('Hola, {{ nombre }}')
print (t.render(Context({'nombre': nombre})))

# Bien
t = Template('Hola, {{ nombre }}')
for nombre in ('Juan', 'Julia', 'Paty'):
print (t.render(Context({'nombre': nombre})))

Ejemplo  de uso de  (.) en Template:

In [21]: persona = {'nombre':'Silvia','edad':'43'}

In [22]: tem = Template('{{persona.nombre}} tiene {{persona.edad}} años')

In [23]: con = Context({'persona':persona})

In [24]: tem.render(con)
Out[24]: 'Silvia tiene 43 años'

Ejemplo con Clases:

>>> from django.template import Template, Context
>>> class Persona(object):
... def __init__(self, nombre, apellido):
... self.nombre, self.apellido = nombre, apellido
>>> t = Template('Hola, {{ persona.nombre }}
{{ persona.apellido }}.')
>>> c = Context({'persona': Persona('Juan', 'Pérez')})
>>> t.render(c)
u'Hola, Juan Pérez.'

Ejemplo con listas:

In [32]: t = Template('Fruta 2 es {{frutas.2}}')

In [33]: c = Context({'frutas':['manzana','platano','pera']})

In [34]: t.render(c)
Out[34]: 'Fruta 2 es pera'
Los índices negativos de las listas no están permitidos. Por ejemplo, la variable
{{ frutas. -1 }} causará una TemplateSyntaxError.

La llamada a los métodos es ligeramente más compleja que los otros tipos de
búsqueda. Aquí hay algunas cosas a tener en cuenta:
-> Si, durante la búsqueda de método, un método provoca una excepción, la
excepción será propagada, a menos que la excepción tenga un atributo
silent_variable_failure cuyo valor sea True.
-> Si la excepción contiene el atributo silent_variable_failure, la variable será
renderizada como un string vacío, por ejemplo:

>>> t = Template("Mi nombre es {{ persona.nombre }}.")
>>> class ClasePersona:
... def nombre(self):
... raise AssertionError, "foo"
>>> p = ClasePersona()
>>> t.render(Context({"persona": p}))
Traceback (most recent call last):
...
AssertionError: foo
>>> class SilentAssertionError(AssertionError):
... silent_variable_failure = True
>>> class ClasePersona2:
... def nombre(self):
... raise SilentAssertionError
>>> p = ClasePersona2()
>>> t.render(Context({"persona": p}))
u'Mi nombre es .'

-> La llamada a un método funcionará sólo si el método no requiere argumentos.
En otro caso, el sistema pasará a la siguiente búsqueda de tipo índice de lista.
-> Evidentemente, algunos métodos tienen efectos secundarios, por lo que sería
absurdo, en el mejor de los casos, y posiblemente un agujero de seguridad,
permitir que el sistema de plantillas tenga acceso a ellos.
Digamos, por ejemplo, que tienes un objeto CuentaBanco que tiene un
método borrar(). Una plantilla no debería permitir incluir algo como {{
cuenta.borrar }}, donde cuenta es un objeto CuentaBanco, ¡ya que el objeto
será borrado cuando se renderice la plantilla!
Para prevenir esto, asigna el atributo alters_data de la función en el método:
def delete(self):
    # Borra una cuenta
    delete.alters_data = True

¿Cómo se manejan las variables inválidas?

De forma predeterminada, si una variable no existe, el sistema de plantillas renderiza
esta como una cadena vacía, fallando silenciosamente, por ejemplo:
>>> from django.template import Template, Context
>>> t = Template('Tu nombre es {{ nombre }}.')
>>> t.render(Context())
u'Tu nombre es .'
>>> t.render(Context({'var': 'hola'}))
u'Tu nombre es .'
>>> t.render(Context({'NOMBRE': 'hola'}))
u'Tu nombre es .'
>>> t.render(Context({'Nombre': 'hola'}))
u'Tu nombre es .

El sistema falla silenciosamente en vez de levantar una excepción porque intenta
ser flexible a los errores humanos. En este caso, todas las búsquedas fallan porque los
nombres de las variables, o su capitalización es incorrecta. En el mundo real, es
inaceptable para un sitio web ser inaccesible debido a un error de sintaxis tan
pequeño.

Etiquetas básicas de plantillas y filtros

En Python y en el sistema de plantillas de Django, los siguientes objetos son
evaluados como False (falsos) en un contexto booleano:
-> Una lista vacía ([]),
-> Una tupla vacía (()),
-> Un diccionario vacío ({}),
-> Una cadena vacía (''),
-> El cero (0),
-> El objeto especial None
-> El objeto False (obviamente)
-> Objetos personalizados que definen su propio comportamiento en un contexto
boleano (Es la ventaja de usar Python)
-> Todo lo demás es evaluado como verdadero (True)

None: es un valor especial de Python que devuelven funciones que o bien no
tienen sentencia de return o bien tienen una sentencia de return sin argumento.

Etiquetas
if/else
La etiqueta {% if %} evalúa una variable, y si esta es ‘‘true’’ (esto es, existe, no está
vacía y no es un valor Boolean falso), el sistema mostrará todo lo que hay entre {% if
%} y {% endif %}, por ejemplo:
{% if es_fin_de_semana %}
<p>¡Bienvenido fin de semana!</p>
{% endif %}
La etiqueta {% else %} es opcional:
{% if es_fin_de_semana %}
<p>¡Bienvenido fin de semana!</p>
{% else %}
<p>De vuelta al trabajo.</p>
{% endif %}

La etiqueta {% if %} acepta and, or, o not para testear múltiples variables, o para
negarlas,
por ejemplo:
{% if lista_atletas and lista_entrenadores %}
Atletas y Entrenadores están disponibles
{% endif %}
{% if not lista_atletas %}
No hay atletas
{% endif %}
{% if lista_atletas or lista_entrenadores %}
Hay algunos atleta o algunos entrenadores
{% endif %}
{% if not lista_atletas or lista_entrenadores %}
No hay atletas o no hay entrenadores.
{% endif %}
{% if lista_atletas and not lista_entrenadores %}
Hay algunos atletas y absolutamente ningún entrenador.
{% endif %}

Las etiquetas {% if %} no permiten las cláusulas and y or en la misma etiqueta,
porque el orden de evaluación lógico puede ser ambiguo. Por ejemplo, esto es
inválido:
{% if lista_atletas and lista_entrenadores or lista_porristas %}

No hay una etiqueta {% elif %}. En su lugar usa varias etiquetas {% if %} anidadas
para conseguir el mismo resultado
Usar varias veces el mismo operador lógico está bien, pero no puedes combinar
diferentes operadores. Por ejemplo, esto es válido.

Asegúrate de cerrar cada {% if %} con un {% endif %}. En otro caso, Django
levantará la excepción TemplateSyntaxError.

For:

Cada vez que atravesamos el bucle, el sistema de plantillas renderizará todo entre
{% for %} y {% endfor %}.
Por ejemplo, puedes usar lo siguiente para mostrar una lista de atletas tomadas de
la variable lista_atletas:
<ul>
{% for atleta in lista_atletas %}
<li>{{ atleta.nombre }}</li>
{% endfor %}
</ul>
Agrega reversed a la etiqueta para iterar sobre la lista en orden inverso:
{% for atleta in lista_atletas reversed %}
...
{% endfor %}
Es posible anidar etiquetas {% for %}:
{% for pais in paises %}
<h1>{{ pais.nombre }}</h1>
<ul>
{% for ciudad in pais.lista_ciudades %}
<li>{{ ciudad }}</li>
{% endfor %}
</ul>
{% endfor %}

Un uso muy común de la etiqueta for, es para comprobar el tamaño de una lista
antes de iterar sobre ella y mostrar algún texto en especial, si la lista está vacía.

{% if lista_atletas %}
{% for atleta in lista_atletas %}
<p>{{ atleta.nombre }}</p>
{% endfor %}
{% else %}
<p>No hay atletas. Únicamente programadores.</p>
{% endif %}
El ejemplo anterior es tan común, que la etiqueta for soporta una clausula
opcional:
{% empty %} que te permite definir lo que hay que hacer si la lista está vacía. El
siguiente ejemplo es equivalente al anterior:
{% for atleta in lista_atletas %}
<p>{{ athlete.nombre }}</p>
{% empty %}
<p>No hay atletas. Únicamente programadores.</p>
{% endfor %}

ifequal/ifnotequal:

El sistema de plantillas de Django a propósito no es un lenguaje de programación
completo y por lo tanto no permite ejecutar sentencias arbitrarias de Python. (Más
sobre esta idea en la sección ‘‘Filosofía y limitaciones’’). Sin embargo, es bastante
común que una plantilla requiera comparar dos valores y mostrar algo si ellos son
iguales -- Django provee la etiqueta
{% ifequal %} para este propósito.
La etiqueta {% ifequal %} compara dos valores y muestra todo lo que se encuentra
entre {% ifequal %} y {% endifequal %} si el valor es igual.
Este ejemplo compara las variables usuario y actual_usuario de la plantilla:

{% ifequal usuario actual_usuario %}
<h1>¡Bienvenido!</h1>
{% endifequal %}
Los argumentos pueden ser strings ‘‘hard-codeados’’, con comillas simples o
dobles, por lo que lo siguiente es válido:
{% ifequal seccion 'noticias' %}
<h1>Noticias</h1>
{% endifequal %}
{% ifequal seccion "comunidad" %}
<h1>Comunidad</h1>
{% endifequal %}
Tal como {% if %}, la etiqueta {% ifequal %} admite opcionalmente la etiqueta
{% else %}:
{% ifequal seccion 'noticias' %}
<h1>Noticias</h1>
{% else %}
<h1>No hay noticias nuevas</h1>
{% endifequal %}

En las variables de plantilla, únicamente las cadenas de texto, enteros y los
números decimales son permitidos como argumentos para {% ifequal %}. Estos son
ejemplos válidos:
{% ifequal variable 1 %}
{% ifequal variable 1.23 %}
{% ifequal variable 'foo' %}
{% ifequal variable "foo" %}

Comentarios:

Al igual que en HTML o en un lenguaje de programación como Python, el lenguaje de
plantillas de Django permite usar comentarios. Para designar un comentario, usa {#
#}:
{# Esto es un comentario #}
Este comentario no será mostrado cuando la plantilla sea renderizada.
Un comentario no puede abarcar múltiples líneas. Esta limitación mejora la
performance del analizador sintáctico de plantillas. En la siguiente plantilla, la salida
del renderizado mostraría exactamente lo mismo que la plantilla (esto es, la etiqueta
comentario no será tomada como comentario):
Esto es una {# Esto no es
un comentario #}
prueba.
Si quieres usar un comentario que abarque varias líneas, usa la etiqueta {%
comment %}, así:
{% comment %}
Este es un comentario
que abarca varias líneas
{% endcomment %}

Filtros:

Como explicamos anteriormente en este capítulo, los filtros de plantillas son formas
simples de alterar el valor de una variable antes de mostrarla. Los filtros se parecen a
esto:
{{ nonmbre|lower }}

Los filtros pueden ser encadenados -- esto quiere decir que, la salida de uno de los
filtros puede ser aplicada al próximo--. Aquí un ejemplo que toma el primer elemento
de una lista y la convierte a mayusculas:
{{ mi_lista|first|upper }}

Algunos filtros toman argumentos. Un filtro con argumentos se ve de este modo:
{{ bio|truncatewords:"30" }}

Filtros mas importantes:

Los siguientes son algunos de los filtros más importantes; el Apéndice E cubre el
resto.
-> addslashes: Agrega una contra-barra antes de cualquier contra-barra, comilla
simple o comilla doble. Esto es útil si el texto producido está incluido en un
string de JavaScript.
-> date: Formatea un objeto date o datetime de acuerdo al formato tomado
como parámetro, por ejemplo:
{{ fecha|date:"F j, Y" }}
-> escape: Escapa ampersands(&), comillas, y corchetes del string tomado. Esto
es usado para desinfectar datos suministrados por el usuario y asegurar que
los datos son válidos para XML y XHTML. Específicamente, escape hace estas
conversiones:
• Convierte & en &amp;
• Convierte < en &lt;
• Convierte > en &gt;
• Convierte " (comilla doble) en &quot;
• Convierte ' (comilla simple) en &#39;

-> length: Retorna la longitud del valor. Puedes usar este con una lista o con un
string, o con cualquier objeto Python que sepa como determinar su longitud
(o sea cualquier objeto que tenga el método __len__()).

Filosofía y Limitaciones:

-> La lógica de negocios debe ser separada de la presentación lógicas Vemos al
sistema de plantillas como una herramienta que controla la presentación y la
lógica relacionado a esta -- y eso es todo. El sistema de plantillas no debería
admitir funcionalidad que vaya más allá de este concepto básico.
Por esta razón, es imposible llamar a código Python directamente dentro de
las plantillas de Django. Todo ‘‘programador’’ está fundamentalmente
limitado al alcance de lo que una etiqueta puede hacer. Es posible escribir
etiquetas personalizadas que hagan cosas arbitrarias, pero las etiquetas de
Django intencionalmente no permiten ejecutar código arbitrario de Python.

-> La sintaxis debe ser independiente de HTML/XML. Aunque el sistema de
plantillas de Django es usado principalmente para producir HTML, este
pretende ser útil para formatos no HTML, como texto plano. Algunos otros
lenguajes de plantillas están basados en XML, poniendo toda la lógica de
plantilla con etiquetas XML o atributos, pero Django evita deliberadamente
esta limitación. Requerir un XML válido para escribir plantillas introduce un
mundo de errores humanos y mensajes difícil de entender, y usando un motor
de XML para parsear plantillas implica un inaceptable nivel de overhead en el
procesamiento de la plantilla.

-> Se supone que los diseñadores no son programadores Python. El sistema
de plantillas de los autores reconoce que las plantillas de las páginas web son
en la mayoría de los casos escritos por diseñadores, no por programadores, y
por esto no debería asumir ningún conocimiento de Python.

-> No se pretende inventar un lenguaje de programación. El objetivo es
ofrecer sólo la suficiente funcionalidad de programación, tales como
ramificación e iteración, que son esenciales para hacer presentaciones
relacionadas a decisiones.

Como resultado de esta filosofía, el lenguaje de plantillas de Django tiene las
siguientes limitaciones:

-> Una plantilla no puede asignar una variable o cambiar el valor de esta. Esto es
posible escribiendo una etiqueta personalizada para cumplir con esta meta
(ve el capítulo 10), pero la pila de etiquetas de Django no lo permite.
-> Una plantilla no puede llamar código Python crudo. No hay forma de ingresar
en ‘‘modo Python’’ o usar sentencias puras de Python. De nuevo, esto es
posible creando plantillas personalizadas, pero la pila de etiquetas de Django
no lo permite.

Usando el sistema de plantillas en las vistas:

Cargadores de plantillas:

Hay algunas cosas que notar:
-> Puedes especificar cualquier directorio que quieras, siempre y cuando la
cuenta de usuario en la cual se ejecuta el servidor web tengan acceso al
directorio y a su contenido. Si no puedes pensar en un lugar apropiado para
poner las plantillas, te recomendamos crear un directorio templates dentro
del proyecto de Django (esto es, dentro del directorio misitio que creaste en el
capítulo 2 , si vienes siguiendo los ejemplos a lo largo del libro).
-> Si tu variable TEMPLATE_DIRS contiene únicamente un directorio, ¡no
olvides poner una coma al final de la cadena de texto!

Nota: En la variable TEMPLATE(DIRS)  poner las direcciones de las plantilla

-> Es muy sencillo usar rutas absolutas (esto es, las rutas de directorios
comienzan desde la raíz del sistema de archivos). Pero si quieres ser un poco
más flexible e independiente, puedes tomar el hecho de que el archivo de
configuración de Django es sólo código Python y construir la variable
TEMPLATE_DIRS dinámicamente, por ejemplo:
import os.path
TEMPLATE_DIRS = (
os.path.join(os.path.dirname(__file__), 'templates').replace('\\','/'),
)
Este ejemplo usa la variable ‘‘mágica’’ de Python __file__, la cual es
automáticamente asignada al nombre del archivo del módulo de Python en el
que se encuentra el código.

Uso del metodo render(): Cumple la funcion de Context,get_template,HttpRequest
Definicion: render(request,<plantilla.html>,contexto)

Subdirectorios de get_template()

Puede ser un poco inmanejable guardar todas las plantillas en un solo directorio.
Quizás quieras guardar las plantillas en subdirectorios del directorio de tus plantillas,
y esto está bien. De hecho, recomendamos hacerlo; algunas de las características más
avanzadas de Django (como las vistas genéricas del sistema, las cuales veremos en el
capítulo 11) esperan esta distribución de las plantillas como una convención por
omisión.No hay límites para la profundidad del árbol de subdirectorios. Siéntete libre de
usar tantos como quieras o necesites.

Ejemplo:
t = get_template('aplicacion/fecha_actual.html')
render(request, 'aplicacion/fecha_actual.html', {'fecha_actual': ahora})

La etiqueta de plantilla include

Ahora que hemos visto en funcionamiento el mecanismo para cargar plantillas,
podemos introducir un tipo de plantilla incorporada que tiene una ventaja para esto:
{% include %}. Esta etiqueta te permite incluir el contenido de otra plantilla. El
argumento para esta etiqueta debería ser el nombre de la plantilla a incluir, y el
nombre de la plantilla puede ser una variable string hard-coded (entre comillas),
entre simples o dobles comillas. En cualquier momento que tengas el mismo código
en varias etiquetas, considera utilizar la etiqueta {% include %} para eliminar la
redundancia entre las plantillas.

Estos dos ejemplos incluyen el contenido de la plantilla nav.html. Los ejemplos son
equivalentes e ilustran que cualquier modo de comillas está permitido:
{% include 'nav.html' %}
{% include "nav.html" %}
Este ejemplo incluye el contenido de la plantilla includes/nav.html:
{% include 'includes/nav.html' %}
Este ejemplo incluye el contenido de la plantilla cuyo nombre se encuentra en la
variable template_name:
{% include template_name %}

Herencia de plantillas

El primer paso es definir una plantilla base -- un ‘‘esqueleto’’ de tu página que las
plantillas hijas llenaran luego.
Aquí hay una plantilla para nuestro ejemplo actual:

<!DOCTYPE HTML PUBLIC "­//W3C//DTD HTML 4.01//EN">
<html lang="en">
<head>
<title>{% block title %}{% endblock %}</title>
</head>
<body>
<h1>Mi sitio Web</h1>
{% block content %}{% endblock %}
{% block footer %}
<hr>
<p>Gracias por visitar nuestro sitio web.</p>
{% endblock %}
</body>
</html>
Usamos una etiqueta de plantillas nueva aquí: la etiqueta {% block %}. Todas las
etiquetas {% block %}, le indican al motor de plantillas que una plantilla hija, quizás
sobrescriba esa parte de la plantilla.

Cuando cargamos una plantilla, por ejemplo fecha_actual.html, el motor de
plantillas ve la etiqueta {% extends %}, nota que esta plantilla es la hija de otra. El
motor inmediatamente carga la plantilla padre --en este caso, base.html.
Hasta este punto, el motor de la plantilla nota las tres etiquetas {% block %} en
base.html y reemplaza estos bloques por el contenido de la plantilla hija. Entonces, el
título que definimos en el bloque {% block title %} será usado, así como el que
definimos en el bloque {% block content %}.
Nota que la plantilla hija no define el bloque footer, entonces el sistema de
plantillas usa el valor de la plantilla padre por defecto. El contenido de la etiqueta {%
block %} en la plantilla padre es usado siempre que no se sobrescribe en una plantilla
hija.
La herencia no afecta el funcionamiento del contexto, y puedes usar tantos niveles
de herencia como necesites. Una forma común de utilizar la herencia es el siguiente
enfoque de tres niveles:

1. Crea una plantilla base.html que contenga el aspecto principal de tu sitio. Esto
es lo que rara vez cambiará, si es que alguna vez cambia.
2. Crea una plantilla base_SECTION.html para cada ‘‘sección’’ de tu sitio (por ej.
base_fotos.html y base_foro.html). Esas plantillas heredan de base.html e
incluyen secciones específicas de estilo y diseño.
3. Crea una plantilla individual para cada tipo de página, tales como páginas de
formulario o galería de fotos. Estas plantillas heredan de la plantilla solo la
sección apropiada.

Aquí hay algunos consejos para trabajar con la herencia de plantillas:

-> Si usas etiquetas {% extends %} en la plantilla, esta debe ser la primera
etiqueta de esa plantilla. En otro caso, la herencia no funcionará.
-> Generalmente, cuanto más etiquetas {% block %} tengas en tus plantillas,
mejor. Recuerda, las plantillas hijas no tienen que definir todos los bloques
del padre, entonces puedes rellenar un número razonable de bloques por
omisión, y luego definir sólo lo que necesiten las plantillas hijas. Es mejor
tener más conexiones que menos.
-> Si encuentras código duplicado en un número de plantillas, esto
probablemente signifique que debes mover ese código a un {% block %} en la
plantilla padre.
-> Si necesitas obtener el contenido de un bloque desde la plantilla padre, la
variable {{ block.super }} hará este truco. Esto es útil si quieres agregar
contenido del bloque padre en vez de sobreescribirlo completamente.
-> No puedes definir múltiples etiquetas {% block %} con el mismo nombre en la
misma plantilla. Esta limitación existe porque una etiqueta bloque trabaja en
ambas direcciones. Esto es, una etiqueta bloque no sólo provee un agujero a
llenar, sino que también define el contenido que llenará ese agujero en el
padre. Si hay dos nombres similares de etiquetas {% block %} en una plantilla,
el padre de esta plantilla puede no saber cuál de los bloques usar (aunque
usara el primero que encuentre).
-> El nombre de plantilla pasado a {% extends %} es cargado usando el mismo
método que get_template(). Esto es, el nombre de la plantilla es agregado a la
variable TEMPLATE_DIRS.
-> En la mayoría de los casos, el argumento para {% extends %} será un string o
cadena, pero también puede ser una variable, si no sabes el nombre de la
plantilla padre hasta la ejecución. Esto te permite hacer cosas divertidas y
dinámicas.

Capitulo 5.Interactuando con una base de datos

Estas tres piezas juntas -- la lógica de acceso a la base de datos, la lógica de
negocios, y la lógica de presentación -- comprenden un concepto que a veces es
llamado el patrón de arquitectura de software Modelo-Vista-Controlador (MVC). En
este patrón, el ‘‘Modelo’’ hace referencia al acceso a la capa de datos, la ‘‘Vista’’ se
refiere a la parte del sistema que selecciona qué mostrar y cómo mostrarlo, y el
‘‘Controlador’’ implica la parte del sistema que decide qué vista usar, dependiendo de
la entrada del usuario, accediendo al modelo si es necesario

Django sigue el patrón MVC tan al pie de la letra que puede ser llamado un
framework MVC. Someramente, la M, V y C se separan en Django de la siguiente
manera:
-> M, la porción de acceso a la base de datos, es manejada por la capa de la base
de datos de Django, la cual describiremos en este capítulo.
-> V, la porción que selecciona qué datos mostrar y cómo mostrarlos, es
manejada por la vista y las plantillas.
-> C, la porción que delega a la vista dependiendo de la entrada del usuario, es
manejada por el framework mismo siguiendo tu URLconf y llamando a la
función apropiada de Python para la URL obtenida.

Debido a que la ‘‘C’’ es manejada por el mismo framework y la parte más
emocionante se produce en los modelos, las plantillas y las vistas, Django es
conocido como un Framework MTV. En el patrón de diseño MTV.

-> M significa ‘‘Model’’ (Modelo), la capa de acceso a la base de datos. Esta capa
contiene toda la información sobre los datos: cómo acceder a estos, cómo
validarlos, cuál es el comportamiento que tiene, y las relaciones entre los
datos.
-> T significa ‘‘Template’’ (Plantilla), la capa de presentación. Esta capa contiene
las decisiones relacionadas a la presentación: como algunas cosas son
mostradas sobre una página web o otro tipo de documento.
-> V significa ‘‘View’’ (Vista), la capa de la lógica de negocios. Esta capa contiene
la lógica que accede al modelo y la delega a la plantilla apropiada: puedes
pensar en esto como un puente entre los modelos y las plantillas.

Configuracion de la base de datos

Asumiremos que ya haz configurado un servidor de base de datos, lo has activado,
y has creado una base de datos en este punto (por ej. usando la sentencia CREATE
DATABASE). SQLite es un caso especial; ya que en este caso, no hay que crear una
base de datos manualmente, porque SQLite usa un archivo autónomo sobre el
sistema de archivos para guardar los datos y Django lo crea automáticamente.
Como con TEMPLATE_DIRS en los capítulos anteriores, la configuración de la base
de datos se encuentra en el archivo de configuración de Django, llamado, por
omisión, settings.py. Edita este archivo y busca las opciones de la variable
DATABASES, el cual es un diccionario que contiene los ajustes necesarios, para
configurar la base datos:
ENGINE = ''
NAME = ''
USER = ''
PASSWORD = ''
HOST = ''
DATABASE_PORT = ''

-> ENGINE: le indica a Django qué base de datos utilizar. Si usas una base de datos
con Django, ENGINE debe configurarse con una cadena de los mostrados en la
Tabla 5-1.

Tabla 5.1 Adaptadores requeridos en Django

Configuración                           Base de datos             Adaptador requerido
django.db.backends.postgresql_psycopg2  PostgreSQL                Psycopg version 2.x,
                                                                  http://www.djangoproject.com/r/python-pgsql/.
django.db.backends.mysql                MySQL                     MySQLdb,http://www.djangoproject.com/r/p
                                                                  ython-mysql/.
django.db.backends.sqlite3              SQLite                    No necesita adaptador
django.db.backends.oracle               Oracle                    cx_Oracle,http://www.djangoproject.com/r/p
                                                                  ython-oracle/.

-> NAME la indica a Django el nombre de tu base de datos. Si estás usando SQLite,
especifica la ruta completo del sistema de archivos hacia el archivo de la base de
datos (por ej. '/home/django/datos.db').
-> USER le indica a Django cual es el nombre de usuario a usar cuando se conecte
con tu base de datos. Si estás usando SQLite, deja este en blanco.
-> PASSWORD le indica a Django cual es la contraseña a utilizar cuando se conecte
con tu base de datos. Si estás utilizando SQLite o tienes una contraseña vacía,
deja este en blanco.
-> HOST le indica a Django cual es el host a usar cuando se conecta a tu base de
datos. Si tu base de datos está sobre la misma computadora que la instalación de
Django (o sea localhost), deja este en blanco. Si estás usando SQLite, deja este en
blanco
-> PORT le indica a Django qué puerto usar cuando se conecte a la base de datos. Si
estás utilizando SQLite, deja este en blanco. En otro caso, si dejas este en blanco,
el adaptador de base de datos subyacente usará el puerto por omisión acorde al
servidor de base de datos. En la mayoría de los casos, el puerto por omisión está
bien, por lo tanto puedes dejar este en blanco.

MySQL es un caso especial aquí. Si este valor comienza con una barra ('/') y estás
usando MySQL, MySQL se conectará al socket especificado por medio de un
socket Unix, por ejemplo:
DATABASE_HOST = '/var/run/mysql'
Si estás utilizando MySQL y este valor no comienza con una barra, entonces este
valor es asumido como el host

Comprobacion de la funcionalidad de la bd:

>>> from django.db import connection
>>> cursor = connection.cursor()


Tu Primera aplicacion

-> Un proyecto es una instancia de un cierto conjunto de aplicaciones de Django,
 más las configuraciones de esas aplicaciones. Técnicamente, el único
 requerimiento de un proyecto es que este suministre un archivo de configuración
 o settings.py, el cual define la información hacia la conexión a la base de datos, 
 la lista de las aplicaciones instaladas, la variable TEMPLATE_DIRS, y así
 sucesivamente.

-> Una aplicación es un conjunto portable de alguna funcionalidad de Django,
típicamente incluye modelos y vistas, que conviven en un solo paquete de Python
(Aunque el único requerimiento es que contenga una archivo models.py).

No obstante, existe un requisito respecto a la convención de la aplicación: si estás
usando la capa de base de datos de Django (modelos), debes crear una aplicación de
Django. Los modelos deben vivir dentro de aplicaciones.

-> python manage.py startapp <nobre de app> # Para crear uan aplicacion

Definir modelos en Python:

Tips:

-> La introspección requiere overhead y es imperfecta. Con el objetivo de
proveer una API conveniente de acceso a los datos, Django necesita conocer
de alguna forma la capa de la base de datos, y hay dos formas de lograr esto.
La primera sería describir explícitamente los datos en Python, y la segunda
sería la introspección de la base de datos en tiempo de ejecución para
determinar el modelo de la base de datos.
La segunda forma parece clara, porque los metadatos sobre tus tablas se
alojan en un único lugar, pero introduce algunos problemas. Primero,
introspeccionar una base de datos en tiempo de ejecución obviamente
requiere overead o sobrecarga. Si el framework tuviera que introspeccionar la
base de datos cada vez que se procese una petición, o incluso cuando el
servidor web sea inicializado, esto podría provocar un nivel de sobrecarga
inaceptable. (Mientras algunos creen que el nivel de overhead es aceptable,
los desarrolladores de Django apuntan a quitar del framework tanto overhead
como sea posible, y esta aproximación hace que Django sea más rápido que
los frameworks competidores de alto nivel en mediciones de desempeño).
Segundo, algunas bases de datos, notablemente viejas versiones de MySQL,
no guardan suficiente metadatos para asegurarse una completa introspección.

-> Escribir Python es divertido, y dejar todo en Python limita el número de veces
que tu cerebro tiene que realizar un ‘‘cambio de contexto’’. Si te mantienes en
un solo entorno/mentalidad de programación tanto tiempo como sea posible,
ayuda para la productividad. Teniendo que escribir SQL, luego Python, y
luego SQL otra vez es perjudicial.

-> Tener modelos de datos guardados como código en vez de en tu base de datos
hace fácil dejar tus modelos bajo un control de versiones. De esta forma,
puedes fácilmente dejar rastro de los cambios a tu capa de modelos.

-> SQL permite sólo un cierto nivel de metadatos acerca de un layout de datos.
La mayoría de sistemas de base de datos, por ejemplo, no provee un tipo de
datos especializado para representar una dirección web o de email. Los
modelos de Django sí. La ventaja de un tipo de datos de alto nivel es la alta
productividad y la reusabilidad de código.

-> SQL es inconsistente a través de distintas plataformas. Si estás
redistribuyendo una aplicación web, por ejemplo, es mucho más pragmático 
distribuir un módulo de Python que describa tu capa de datos que separar
conjuntos de sentencias CREATE TABLE para MySQL, PostgreSQL y SQLite.

Nota:
Una contra de esta aproximación, sin embargo, es que es posible que el código
Python quede fuera de sincronía respecto a lo que hay actualmente en la base. Si
haces cambios en un modelo Django, necesitarás hacer los mismos cambios dentro
de tu base de datos para mantenerla consistente con el modelo. Detallaremos
algunas estrategias para manejar este problema más adelante en este capítulo.
Finalmente, Django incluye una utilidad que puede generar modelos haciendo
introspección sobre una base de datos existente. Esto es útil para comenzar a trabajar
rápidamente sobre datos heredados.

Tu primer Modelo

-> Crear los modelos en el script models.py
-> Editar el archivo de configuracion setting.py y agregar la app a la variable INSTALLED_APPS
-> Si estás usando PostgreSQL, Oracle o MySQL, debes asegurarte de crear una base de datos en este punto. 
Lo puedes hacer con el comando ‘‘CREATE DATABASE
nombre_base_de_datos;’’ mediante el intérprete interactivo de la base de datos.

Nota: Asegúrate de instalar la librería de imágenes Pillow, para validacion de imagenes para django
También agrega la ruta al directorio en donde se guardaran las imágenes,
especificándolo en el archivo de configuraciones settings.py y usando la variable
MEDIA_ROOT:
MEDIA_ROOT = 'media/'

Y La URL que se encargara de servir dichas imágenes MEDIA_URL, por ejemplo
asumiendo que estas usando el servidor de desarrollo:
MEDIA_URL = 'http://localhost:8000/media/'

-> Crear o cambiar el modelo (en models.py)
-> Validar la logica y sintaxis de los modelos, esto no afecta la bd: python manage.py check biblioteca.
-> Guardar las migraciones para los modelos en un archivo de control, para que Django pueda encontrarlas al sincronizar
el esquema de la base de datos: python manage.py makemigrations
-> Para ver el sql generado: python manage.py sqlmigrate <nombre de la db>
-> Para realizar los cambios al esquema de la base de datos usar: python manage.py migrate. Crea las tablas de las bds.

Nota: El comando migrate es una simple sincronizacion de tus modelos a la bd. Este comando examina todos los modelos en 
cada aplicacion que figure en la variable INSTALLED_APPS, verifiaca si existen las tablas y si no las crea. Las migraciones
nos permiten cambiar los modelos cada cierto plazo de tiempo, sin la necesidad de borrar las tablas o la bd; el proposito 
consiste en actualizar las bds que usamos sin perder datos.

Comandos utiles en Base de datos:

-> python manage.py dbshell, deducira que cliente de linea de comando ejecutar.
-> Para verificar bds usar: \dt (PostgreSQL),SHOW TABLES (MySQL), .schema (SQLite)


Migraciones 

En este punto, quizás te preguntes ¿Que son las migraciones? Las migraciones
son la forma en que Django se encarga de guardar los cambios que realizamos a los
modelos (Agregando un campo, una tabla o borrando un modelo... etc.) en el
esquema de la base de datos. Están diseñadas para funcionar en su mayor parte de
forma automática, utilizan una versión de control para almacenar los cambios
realizados a los modelos y son guardadas en un archivo del disco llamado ‘‘migration
files’’, que no es otra cosa más que archivos Python, por lo que están disponibles en
cualquier momento.


Acceso basico a datos 

Usar comando python manage.py shell para interactuar con la bd

-> Para crear un objeto, sólo importa la clase del modelo apropiado y crea una
instancia pasándole valores para cada campo.

-> Para guardar el objeto en la base de datos, llama el método save() del objeto.
Detrás de la escena, Django ejecuta aquí una sentencia SQL INSERT.

-> Para recuperar objetos de la base de datos, usa el atributo Editor.objects.
Busca una lista de todos los objetos Editor en la base de datos con la sentencia
Editor.objects.all(). Detrás de escenas, Django ejecuta aquí una sentencia SQL
SELECT.

-> Para crear y guardar un objeto en un solo paso usar <nombre de tabla>.object.create(...)


Agregar cadenas de representacion a tus modelos

Utilizar el metodo __str__() para la correcta interpretacion de los datos 
unicode. Los objetos Unicode no tienen una codificación, su uso es consistente, son un
conjunto universal de caracteres llamado ‘‘Unicode.’’ Cuando se utilizan objetos
Unicode en Python, puedes mezclarlos y acoplarlos con seguridad, si tener que
preocupare sobre problema de codificación.
Django utiliza objetos Unicode en todo el framework. Los objetos de los modelos
son recuperados como objetos Unicode, las vistas interactúan con datos Unicode, y
las plantillas son renderizadas como Unicode. Generalmente no debes preocuparte
por esto, solo asegúrate que tus codificaciones sean correctas; y las cosas trabajaran
bien.

Nota: para conocer el id de un objeto instanciado usar en el shell <instancia>.id.
Las llamadas sucesivas de una misma instancia al metodo save() actualizaran el objeto creado

Nota: Para ver el Zen de Python en el prompt: import this


Seleccionar Objetos

-> En primer lugar, tenemos nuestro modelo definido, Editor. Aquí no hay nada
extraño: cuando quieras buscar datos, usa el modelo para esto.

-> Luego, tenemos objects. Técnicamente, esto es un administrador (manager).
Los administradores son discutidos en el Capítulo10. Por ahora, todo lo que
necesitas saber es que los administradores se encargan de realizar todas las
operaciones a ‘‘nivel de tablas’’ sobre los datos incluidos, y lo más importante:
las consultas.

-> Todos los modelos automáticamente obtienen un administrador objects;
debes usar el mismo cada vez que quieras consultar sobre una instancia del
modelo.

-> Finalmente, tenemos all(). Este es un método del administrador objects que
retorna todas las filas de la base de datos. Aunque este objeto se parece a una
lista, es realmente un QuerySet -- un objeto que representa algún conjunto de
filas de la base de datos. El Apéndice C describe QuerySets en detalle. Para el
resto de este capítulo, sólo trataremos estos como listas emuladas.


Filtrar datos 

Usar el metodo filter(...).Ejemplo:
>>>Editor.objects.filter(nombre="Apress Publishing")
[<Editor: Apress Publishing>]

Puedes pasarle a filter() múltiples argumentos, para reducir las cosas aún más:
>>>Editor.objects.filter(ciudad="Berkeley", estado="CA"). Equivalente a usar una sentencia and en SQL.
[<Editor: Apress Publishing>]

>>> Editor.objects.filter(nombre__contains="press"). El __ es equivalente a like en SQL.


Obtener Objetos individuales

Usar el metodo .get(...) para obtener un unico objeto. Ejemplo:
>>> Editor.objects.get(nombre="Apress Publishing")
<Editor: Apress Publishing>
Nota: En lugar de una lista (o más bien, un QuerySet), este método retorna un objeto
individual. Debido a eso, una consulta cuyo resultado contenga múltiples objetos
causará una excepción:
>>> Editor.objects.get(pais="U.S.A.")
Traceback (most recent call last):
...
MultipleObjectsReturned: get() returned more than one Editor ­­
it returned 2! Lookup parameters were {'pais': 'U.S.A.'}


Ordenar datos

Para ordenar datos usar el metodo order_by(...). Ejemplo:

>>> Editor.objects.order_by("nombre")
[<Editor: Addison­Wesley>, <Editor: Apress Publishing>, <Editor: O'Reilly>]
Nota: Se ordena por cualquier campo.

Para ordenar por múltiples campos (donde el segundo campo es usado para quitar
las ambigüedades en el orden, en casos donde el nombre sea el mismo), puedes usar
múltiples argumentos:
>>> Editor.objects.order_by("estado", "domicilio")
[<Editor: Apress Publishing>, <Editor: O'Reilly>, <Editor: Addison­Wesley>]

También podemos especificar un ordenamiento inverso antecediendo al nombre
del campo un prefijo - (el símbolo menos):
>>> Editor.objects.order_by("­nombre")
[<Editor: O'Reilly>, <Editor: Apress Publishing>, <Editor: Addison­Wesley>]

Aunque esta flexibilidad es útil, usar order_by() todo el tiempo puede ser
demasiado repetitivo. La mayor parte del tiempo tendrás un campo en particular por
el que usualmente desearás ordenar tus datos. Es esos casos Django te permite
anexar al modelo un ordenamiento por omisión, usando una clase interna Meta:

Clase Meta: Podemos usar una clase Meta en cualquier modelo para especificar varias
opciones específicas en un modelo. En el ejemplo anterior ordering = ["nombre"] le indica a
Django que a menos que se proporcione un ordenamiento mediante order_by(),
todos los editores deberán ser ordenados por su nombre.


Encadenar busquedas

>>> Editor.objects.filter(pais="U.S.A.").order_by("­nombre")
[<Editor: O'Reilly>, <Editor: Apress Publishing>, <Editor: Addison­Wesley>]

Puedes encadenar consultas en forma consecutiva tantas veces como desees. No
existe un límite para esto.


Rebanar datos

>>> Editor.objects.all()[0]
<Editor: Addison­Wesley>

Similarmente, puedes recuperar un subconjunto específico de datos usando la
sintaxis de Python y rebanando un rango de datos:
>>> Editor.objects.order_by('nombre')[0:2]

Nota: Observa que el rebanado negativo no esta soportado.
Sin embargo es fácil darle la vuelta a esto. Cambia la declaración order_by() así:
>>> Editor.objects.order_by('­nombre')[0]


Actualizar multiples campos en una sola declaracion

>>> p = Editor.objects.get(nombre='Apress')
>>> p.nombre = 'Apress Publishing'
>>> p.save()
Si estas en un entorno donde otras columnas
de la base de datos puedan cambiar debido a otro proceso, es más elegante cambiar
únicamente una columna que se necesita cambiar. Para esto usa el método update()
cuando consultes objetos. Por ejemplo:
>>> Editor.objects.filter(id=1).update(nombre='Apress Publishing')

El método update() trabaja con cualquier consulta, lo cual quiere decir que
puedes editar múltiples registros a la vez. Esta es la forma en que podemos cambiar
ciudad de 'U.S.A.' a USA en cada registro Editor:
>>> Editor.objects.all().update(ciudad='USA')
2

Borrar objetos

Para eliminar objetos, simplemente llama al método delete() de tu objeto:
>>> p = Editor.objects.get(nombre="Addison­Wesley")
>>> p.delete()
>>> Editor.objects.all()
[<Editor: Apress Publishing>, <Editor: O'Reilly>]

También puedes borrar objetos al por mayor llamando al método delete() en el
resultado de cualquier consulta. Esto es similar a el método update() que mostramos
en la sección anterior:
>>> Editor.objects.filter(ciudad='USA').delete()
>>> Editor.objects.all().delete()
>>> Editor.objects.all()


Capitulo 6. El sitio de administracion 

El paquete de django.contrib

Contenido del paquete de administracion:
-> django.contrib.admin 
-> django.contrib.sessions: ofrece soporte para sesiones anonimas
-> django.contrib.webdesing: ofrece etiquetas para desarrollo web
-> django.contrib.humanize: ofrece etiquetas para darle un toque humano al framework
-> django.contrib.auth: Sistema de autentificación

Activacion del la interfaz

-> Agrega 'django.contrib.admin' a la variable INSTALLED_APPS de tu archivo
de conImagenciones.(El orden en INSTALLED_APPS si importa, sin embargo
estas están ordenadas alfabéticamente para facilitar su lectura, y Django las
carga conforme están ordenadas, este detalle es importante ya que si quieres
que django cargue primero tus plantillas, necesitas poner tu aplicación antes
que el propio 'django.contrib.admin', para que las use.)

-> La interfaz administrativa tiene cuatro dependencias (que dependen unas de
otras), por lo que asegúrate que estén todas activadas:
• django.contrib.auth
• django.contrib.contenttypes
• django.contrib.messages
• django.contrib.sessions

-> Agrega django.contrib.messages.context_processors.messages a
TEMPLATE_CONTEXT_PROCESSORS (a la variable) así como también agrega
django.contrib.auth.middleware.AuthenticationMiddleware y
django.contrib.messages.middleware.MessageMiddleware a
MIDDLEWARE_CLASSES. (Estos están activados por omisión, así que solo
necesitas hacerlo manualmente, si hiciste algún cambio a la configuración o
los habías comentado previamente).

-> Determina que modelos de tus aplicaciones serán editables en la interfaz
administrativa.
No todos los modelos pueden (o deberían) ser editables por los usuarios
administradores, por lo que necesitas ‘‘marcar’’ los modelos que deberían
tener una interfaz de administración. (Añadiendo una clase ModelAdmin al
archivo admin.py.)

-> Por cada uno de los modelos, crea opcionalmente una clase ModelAdmin en
el archivo admin.py, que encapsule las funcionalidades personalizadas y las
opciones específicas, para cada modelo en particular.

-> Instancia una clase AdminSite y registra cada uno de los modelos en la clase
ModelAdmin.

-> Apunta la instancia AdminSite a tu URLconf.

Creando el usuario root:

-> python manage.py createsuperuser

Sigamos interactivamente la salida del comando createsuperuser:
-> Nos pedirá un nombre de usuario. Por defecto utilizara el nombre del sistema.
Introducimos el nombre de nuestra preferencia y presionamos de nuevo enter:
Username (leave blank to use 'your_username'): admin

-> Nos pedirá también una dirección de correo electrónico::
Email address: admin@example.com

-> Finalmente nos pedirá una contraseña. Por lo que es necesario introducir dos
veces la misma contraseña (la segunda vez solo como confirmación de la
primera):
Password: **********
Password (again): *********
Superuser created successfully

Nota: Para personalizar y registrar modelos en models.py Ejemplo:

@admin.register(Autor)
class AutorAdmin(admin.ModelAdmin):
    list_display = ["nombre","apellido","email"]


Como trabaja la interfaz administrativa

Como crear campos opcionales

Para poder ingresar informacion en un modelo y este permita campos nulos 
se hace lo siguiente: se agrea blank=True al campo. Ejemplo:

class Autor(models.Model):
    nombre = models.CharField(max_length=30)
    apellidos = models.CharField(max_length=40)
    email = models.EmailField(blank=True)

Como crear campos numéricos y de fechas opcionales

Se puede especificar Null agregando null=True a los campos donde sea necesario.
De modo que existe una manera más larga de decir esto: si quieres permitir
valores en blanco en un campo (por ejemplo: DateField, TimeField, DateTimeField) o
numerico (por ejemplo: IntegerField, DecimalField, FloatField), necesitas agregar
ambos tipos: null=True y blank=True. Ejemplo:

class Libro(models.Model):
    titulo = models.CharField(max_length=100)
    autores = models.ManyToManyField(Autor)
    editores = models.ForeignKey(Editor)
    fecha_publicacion = models.DateField(blank=True, null=True)
    portada = models.ImageField(upload_to='portadas')


Personalizar las etiquetas de los campos

Por ejemplo, así es como podemos cambiar la etiqueta del campo Autor email a
‘‘e-mail’’ con un guion en medio:
class Autor(models.Model):
    nombre = models.CharField(max_length=30)
    apellidos = models.CharField(max_length=40)
    email = models.EmailField(blank=True, verbose_name='e­mail')

Finalmente, nota que puedes pasar argumentos posicionales a verbose_name,
para lograr una sintaxis ligeramente más compacta. Este ejemplo es equivalente al
anterior:
class Autor(models.Model):
    nombre = models.CharField(max_length=30)
    apellidos = models.CharField(max_length=40)
    email = models.EmailField('e­mail', blank=True)


Clases personalizadas de la interfaz administrativa

Personalizar la lista de cambios

Para hacer que esto suceda, necesitamos definir una clase ModelAdmin para el
modelo Autor. Esta clase es la clave para personalizar la interfaz administrativa y una
de las cosas básicas que nos permite hacer, es especificar la lista de campos que
queremos visualizar en la lista de cambios. Ejemplo

from django.contrib import admin
from biblioteca.models import Editor, Autor, Libro

class AutorAdmin(admin.ModelAdmin):
    list_display = ('nombre', 'apellidos', 'email')
    admin.site.register(Editor)
    admin.site.register(Autor, AutorAdmin)
    admin.site.register(Libro)

Esto es lo que hicimos:

-> Creamos la clase AutorAdmin. Esta clase, la cual es una subclase de
django.contrib.admin.ModelAdmin, se encarga de llevar a cabo la
configuración para un modelo especifico de la interfaz administrativa.
Únicamente especificamos una personalización --list_display, la cual es una
tupla de nombres de campos, que controla que columnas aparecen en la lista
de cambios. Siempre y cuando estos nombres de campos, existan en el
modelo.
-> Alteramos la llamada a admin.site.register(), para agregar AuthorAdmin
después de Autor.
Puedes leer esto como: ‘‘Registra el modelo Autor con las opciones de
AuthorAdmin.’’
La función admin.site.register() toma un subclase ModelAdmin como un
segundo argumento opcional. Si no necesitas especificar un segundo
argumento (como en el caso de Editor y de Libro) Django usara por omisión
las opciones administrativas para el modelo.


Agregando una barra de busqueda

class AutorAdmin(admin.ModelAdmin):
list_display = ('nombre', 'apellidos' 'email')
search_fields = ('nombre', 'apellidos')

Agregando filtros 

(Ejemplo resumen de cambios)

from django.contrib import admin
from biblioteca.models import Editor, Autor, Libro

class AutorAdmin(admin.ModelAdmin):
    list_display = ('nombre', 'apellidos', 'email')
    search_fields = ('nombre', 'apellidos')
    class LibroAdmin(admin.ModelAdmin):
    list_display = ('titulo', 'editor', 'fecha_publicacion')
    list_filter = ('fecha_publicacion',)
    admin.site.register(Editor)
    admin.site.register(Autor, AutorAdmin)
    admin.site.register(Libro, LibroAdmin)

Otra forma de ofrecer los filtros basados en fechas es usando la opción
date_hierarchy así:

class LibroAdmin(admin.ModelAdmin):
    list_display = ('titulo', 'editor', 'fecha_publicacion')
    list_filter = ('fecha_publicacion',)
    date_hierarchy = 'fecha_publicacion'

Usando el ordenamiento

class LibroAdmin(admin.ModelAdmin):
    list_display = ('titulo', 'editor', 'fecha_publicacion')
    list_filter = ('fecha_publicacion',)
    date_hierarchy = 'fecha_publicacion'
    ordering = ('­fecha_publicacion',)


Personalizar formularios de edicion

Cambiando el orden de aparicion en el formulario

class LibroAdmin(admin.ModelAdmin):
    list_display = ('titulo', 'editor', 'fecha_publicacion')
    list_filter = ('fecha_publicacion',)
    date_hierarchy = 'fecha_publicacion'
    ordering = ('­fecha_publicacion',)
    fields = ('titulo', 'autores', 'editor', 'fecha_publicacion')

Ocultar campos para que no sean editables (se quito el campo "fecha_publicacion")

class LibroAdmin(admin.ModelAdmin):
    list_display = ('titulo', 'editor', 'fecha_publicacion')
    list_filter = ('fecha_publicacion',)
    date_hierarchy = 'fecha_publicacion'
    ordering = ('­fecha_publicacion',)
    fields = ('titulo', 'autores', 'editor', 'portada')

En caso de usar campo muchos a muchos, a la hora de la seleccion.

La solución es cambiar la disposición de la interfaz administrativa usando
filter_horizontal.

class LibroAdmin(admin.ModelAdmin):
    list_display = ('titulo', 'editor', 'fecha_publicacion')
    list_filter = ('fecha_publicacion',)
    date_hierarchy = 'fecha_publicacion'
    ordering = ('­fecha_publicacion',)
    filter_horizontal = ('autores',) / filter_vertical

Recomendamos usar el filtro horizontal, filter_horizontal para cualquier campo
ManyToManyField que contenga más de 10 objetos. Es más sencillo de usar que el
widget de selección múltiple. También puedes usar filter_horizontal en campos
múltiples --solo específica cada nombre en una tupla.

Usando la seleccion multiple en ForeignKey

class LibroAdmin(admin.ModelAdmin):
    list_display = ('titulo', 'editor', 'fecha_publicacion')
    list_filter = ('fecha_publicacion',)
    date_hierarchy = 'fecha_publicacion'
    ordering = ('­fecha_publicacion',)
    filter_horizontal = ('autores',)
    raw_id_fields = ('editor',)


Personalizar la apariencia de la interfaz de administracion

Hacer los siguientes cambio en admin.py del la aplicacion (o sitio)

Ejemplo:
admin.site.site_header = "Control Panel"
admin.site.index_title = "Control Panel Site"
admin.site.site_title = "@MBI"


Personalizar la página índice del administrador

Usar la operacion anterior con la plantilla index.html 
Ejemplo:
admin.site.index_template = BASE_DIR + "/templates/admin/index.html"
admin.autodiscover()


Usuarios, Grupos y Permisos

Nota: El acceso a editar usuarios y permisos también es controlado por el sistema
de permisos. Si le das a alguien el permiso de editar usuarios, ¡estará en condiciones
de editar sus propios permisos, que probablemente no es lo que querías!
También puedes asígnar usuarios a grupos. Un grupo es simplemente un conjunto
de permisos a aplicar a todos los usuarios de ese grupo. Los grupos son útiles para
otorgar idénticos permisos a un gran número de usuarios.


Cap_7. Procesamiento de formularios

Obteniendo datos de los objetos "Request"

Atributos o Métodos             Descripción                              Ejemplo
request.path                    La ruta completa, no incluye el          "/hola/"
                                dominio pero incluye, la barra
                                inclinada.

request.get_host()              El host (ejemplo: tu ‘‘dominio,’’ en     "127.0.0.1:8000" o "www.example.com"
                                lenguaje común).

request.get_full_path()         La ruta (path), mas una cadena de        "/hola/?print=true"
                                consulta (si está disponible).

request.is_secure()             True si la petición fue hecha vía        True o False
                                HTTPS. Si no, False.

Ejemplo de uso:

# ¡Mal! 
def vista_actual_url(request):
return HttpResponse("Bienvenido a mi pagina en /pagina_actual/")
# Bien 
def vista_actual_url(request):
return HttpResponse("bienvenido a mi pagina en %s" % request.path)

Informacion sobre las peticiones (Request):

Estas dependen de las que el usuario envia y el servidor seleccione, las mas comunes son:
estas se encuentran en request.META

-> HTTP_REFERER: La respectiva URL, a la que se hace referencia. (Observa la
forma en que se escribe REFERER.)
-> HTTP_USER_AGENT: El navegador del usuario en forma de cadena,
cualquiera que sea. Esta es algo si: "Mozilla/5.0 (X11; U; Linux i686; fr-FR; rv:
1.8.1.17) Gecko/20080829 Firefox/2.0.0.17".
-> REMOTE_ADDR: La dirección IP del cliente, por ejemplo: "12.345.67.89". (Si
la petición ha pasado a través de un proxi, entonces puede retornar una lista
separada por comas, conteniendo las direcciones IP, por ejemplo:
"12.345.67.89, 23.456.78.90".)

# ¡Mal! 
def mostrar_navegador(request):
    ua = request.META['HTTP_USER_AGENT'] # ¡Podría lanzar: KeyError!
    return HttpResponse("Tu navegador es %s" % ua)
# Bien (Versión 1)
def mostrar_navegador(request):
    try:
        ua = request.META['HTTP_USER_AGENT']
    except KeyError:
        ua = 'unknown'
    return HttpResponse("Tu navegador es %s" % ua)
# Bien (Versión 2)
def mostrar_navegador2(request):
    ua = request.META.get('HTTP_USER_AGENT', 'unknown')
    return HttpResponse("Tu navegador es %s" % ua)

INFORMACIÓN ACERCA DE LOS DATOS RECIBIDOS

Más allá de los metadatos básicos obtenidos de las peticiones Web, los objetos
HttpRequest poseen dos atributos mas, que contienen información recibida de los
usuarios: request.GET y request.POST. Ambos atributos son como objetos tipo
diccionarios que permiten el acceso a datos GET y POST


Tu primer formulario creado con Django

En resumen:
-> El formulario HTML (<form>) define una variable q. Cuando esta es subida el
valor de q es enviado mediante el método GET a la URL /buscar/.
-> La vista de Django maneja la URL /buscar/ y tiene acceso al valor de q en la
petición request.GET

Una cosa que es importante precisar aquí, es que explícitamente verificamos
que 'q' exista en request.GET. Como precisamos en la sección anterior con las
peticiones request.META, no deberías confiar en nada que sea subido por los
usuarios o incluso asume que no subieron nada en primer lugar. Si no agregas
esta verificación, los formularios vacios lanzaran un error del tipo KeyError en
la vista:
# MAL! 
def buscar_no_hagas_esto(request):
    #¡Las siguientes lineas lanzan un error "KeyError" si no se envía 'q'!
    mensaje = 'Estas buscando: %r' % request.GET['q']
    return HttpResponse(mensaje)

PARÁMETROS DE CADENAS DE CONSULTA
Porque los datos GET se pasan en cadenas de consultas (por ejemplo:
/buscar/?q=django) puedes usar request.GET para acceder a las variables de las
cadenas de consulta. En el capítulo 3, ‘‘Introducción a los patrones URLconfs de
Django’’, comparamos las URL bonitas contra las tradicionales URLs de PHP/Java tal
como /tiempo/mas?horas=3 y dijimos que te mostraríamos como hacerlo más
adelante en el capítulo 7. Ahora ya sabes cómo acceder a cadenas de parámetros en
las vistas (tal como el ejemplo horas=3) --Solo usa request.GET.
Los datos POST trabajan de la misma forma que lo datos GET -- solo usa
request.POST en lugar de request.GET.
¿Entonces cual es la diferencia entre GET y POST? Usa GET cuando el acto de
subir un formulario solo sea para ‘‘pedir’’ datos. En cambio usa POST siempre que el
acto de subir el formulario tenga efectos secundarios -- cambiando datos, enviando
un e-mail o algo que vaya más allá de simplemente mostrar datos. En el ejemplo de
búsquedas del ejemplo, estamos usando GET porque la consulta no cambia ningún
dato en nuestro servidor.
(Consulta http://www.w3.org/2001/tag/doc/whenToUseGet.html si quieres
aprender más sobre las peticiones GET and POST.)


-> Aparte de checar que 'q' exista en request.GET, nos aseguramos que
request.GET['q'] no sea una cadena vacía antes de pasarle la consulta a la base
de datos.
-> Estamos usando Libro.objects.filter(titulo__icontains=q) para consultar en la
tabla libros, todos los libros que incluyan en el titulo los datos proporcionados
en la consulta, icontains es un tipo de búsqueda (como explicamos en el
capítulo 5 y el apéndice B) en la que no se distinguen mayúsculas de
minúsculas (case-insensitive), y que internamente usa el operador LIKE de
SQL en la base de datos. La declaración puede ser traducida como ‘‘Obtener
todos los libros que contengan estas palabras‘‘

Esta es una forma muy simple para buscar libros. No recomendamos usar una
simple consulta icontains en bases de datos muy grandes en producción ya
que esto puede ser muy lento. (En el mundo real, es mejor usar un sistema de
búsqueda personalizado de cierto tipo. Busca en la Web proyectos libres de
sistemas de búsquedas de texto para que te des una idea de las posibilidades.)

<form action="/buscar/" method="get">
Podemos cambiarlo por esto:
<form action="" method="get">
action="" significa ‘‘Envía el formulario con la misma URL a la pagina actual’’. Con
este cambio realizado, no tienes que recordar cambiar action cada vez que necesites
enlazar la vista buscar() a otra URL


Construir un formulario para contactos

-> Estamos comprobando que request.method sea 'POST'. Esto únicamente será
verdadero en los casos en que se envié el formulario y no en el caso de que
alguien simplemente mira el formulario de contactos (En este último caso
request.method será fijado como 'GET', porque los navegadores Web
normalmente exploran usando GET, no POST.) Esto hace más agradable aislar
‘‘El formulario para mostrar’’ de los casos en que se necesite presentar el
‘‘Procesamiento de formularios’’
-> En lugar de usar request.GET, estamos usando request.POST para acceder a
los datos del formulario de envió. Esto es necesario porque el formulario HTML en
formulario-contactos.html usa method="post". Si la vista es
accedida vía POST, en lugar de request.GET estará vacía.
-> Esta vez tenemos dos campos requeridos, asunto y mensaje, así que tenemos
que validar ambos. Observa que utilizamos request.POST.get() y proveemos
una cadena en blanco como el valor por omisión para el tercer campo; esta es
una manera agradable y corta de manejar ambos casos, para evitar que falten
claves y se pierdan datos.
-> Aunque el campo de email no es requerido, todavía podemos validarlo si nos
lo envían. Nuestro algoritmo de validación es frágil -- solo comprobamos que
la cadena contenga un carácter @. En el mundo real, necesitamos una
validación más robusta (y Django nos la proveerá, en breve te mostraremos
como.)
-> Estamos usando la funcion django.core.mail.send_mail para enviar un e-mail.
Esta función tiene cuatro argumentos obligatorios: el asunto y el cuerpo del
mensaje, la dirección del emisor, y una lista de direcciones del destino.
send_mail es un wrapper en torno a la clase EmailMessage de Django, la cual
provee características avanzadas tales como archivos adjuntos, mensajes
múltiples y un control completo sobre los encabezados del mensaje.
-> Ten en cuenta que para usar el envió de e-mail usando send_mail(), tu
servidor debe de estar configurado para enviar emails, y Django debe de
informar al servidor sobre la salida de e-mails. Más adelante configuraremos
un servidor de correo que te permitirá enviar emails en el proceso de
desarrollo.
-> Después de que el e-mail es enviado con ‘‘éxito’’, redirige al usuario a otra
página retornando un objeto HttpResponseRedirect. Te dejaremos la
implementación de la pagina ‘‘enviado con éxito’’ (ya que es una simple
vista/URLconf/plantilla) pero es necesario explicar que debes usar un
redirecionamiento para dirigir al usuario a otro lugar, en vez de por ejemplo,
simplemente llamar a render() con una plantilla allí mismo


Primer formulario usando Clases

-> Crear un archivo forms.py en el directorio de la aplicacion.
-> Importar Form de django
-> Crear una clase con los campos que se requieran, los que no sean requeridos se les pone required=False.

Nota: Las etiquetas <table>,<ul> y <form> no se incluyen, es para dar mayor accesibilidad al formulario.

Validacion de datos en forms desde la shell: pasar un diccionario de datos que vincule los campos.

-> Una instancia de formulario puede estar en bound (vinculado) o unbound (desvinculado)
-> Usar is_bound() para saber si un formulario esta vinculado.
-> Usar is_valid() para saber si los datos pasados son consistentes.
-> Conocer los errores en un campo: instancia[<'campo'>].errors
-> Usar el metodo "<instancia>.cleaned_data", para limpiar datos (llevarlos a unicode)


Enviar emails usando django
Configurar un servidor de correo en django

Ejemplo:
>>>from django.core.mail import send_mail
>>>send_mail('Este es el argumento', 'Aquí va el mensaje.',
'administrador@example.com', ['para@example.com'], fail_silently=False)

El correo se envía usando el servidor SMPT, con el puerto y el host especificado en
el archivo de configuración setting.py, mediante EMAIL_HOST y EMAIL_PORT,
mientras que las variables EMAIL_HOST_USER y EMAIL_HOST_PASSWORD se usan
para autentificarte con el servidor SMPT si así se requiere, por otra parte
EMAIL_USE_TLS y EMAIL_USE_SSL se utilizan para controlar las conexiones seguras
y por ultimo EMAIL_BACKEND se utiliza para configurar el servidor de correo a
utilizar.

Por omisión Django utiliza SMTP, como la configuración por defecto. Si quieres
especificarla explícitamente usa lo siguiente en el archivo de configuraciones:
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'

Un servidor de correo usando la terminal

Solo necesitas especificar el manejador de correo, usando la siguiente
configuración:
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'

Un servidor de correo "bobo"

Para especificarlo, solo usa la siguiente configuración:
EMAIL_BACKEND = 'django.core.mail.backends.dummy.EmailBackend'

Otra forma de utilizar un servidor SMPT ‘‘tonto’’ que reciba los emails localmente
y puedas visualizarlos en la terminal, es usando una clase incorporada en Python que
inicia un servidor de correo con un solo comando:
python -m smtpd -n -c DebuggingServer localhost:1025


Cambiando la forma en que los campos son renderizados
Especificar valores iniciales

Nota: Se especifican en las vistas donde se crea la instancia de Form

Nuestras propias reglas de validacion

El sistema de formularios de Django, automáticamente busca cualquier método
que empiece con clean_ y termine con el nombre del campo. Si cualquiera de estos
métodos existe, este será llamado durante la validación.
Específicamente, el método clean_mensaje() es llamado después de la validación
lógica para el campo por defecto (en este caso, la validación lógica de el campo
CharField es obligatoria). Dado que los datos del campo ya han sido parcialmente
procesados, necesitamos obtenerlos desde el diccionario self.cleaned_data del
formulario. Por lo que no debemos preocuparnos por comprobar que el valor exista y 
que no esté vacio; ya que el validador se encargara de realizar este trabajo por
defecto.

Como especificar Etiquetas

Nota: Igual que se hace con los modelos


Diseño de formularios personalizados

Cada widget de un campo (<input type="text">, <select>, <textarea>, o similares)
puede generarse individualmente accediendo a {{ form.fieldname }} en la plantilla y
cualquier error asociado con un campo está disponible mediante
{{ form.fieldname.errors }}.


Cap_8. Vistas avanzadas y URLconfs
Trucos de URLconfs

Para aliviar la extension en las importaciones, se recomienda importar views
Ejemplo:... url(r’^hola/$’, views.hola),

Django ofrece otra forma de especificar la función vista para un patrón en
particular en la URLconf: se le puede pasar un string que contiene el nombre del
módulo y el nombre de la función en lugar del método.
Ejemplo:... url(r’^hola/$’, ’misitio.views.hola’), esta no trabaja en la version 3.2.9

Casos especiales de URLs en modo Debug

Trabajar en modo DEBUG, significa sobre todo depurar, por lo que Django, nos
provee de herramientas para manejar los casos más comunes del desarrollo Web,
como manejar archivos estáticos (hojas de estilo, java script) y archivos media
(imágenes, pdf), de forma local. Django hace una gran distinción en el manejo de
estos dos tipos de contenido, mientras que se encarga de servir los archivos estáticos
de forma automática, para servir los archivos media de forma local, es necesario
habilitar una vista opcional y enlazarla a una URLconf en modo DEBUG.

Advertencia: Esta vista es ineficiente y no debe ser usada en producción, por lo
que asegúrate de usarla solo en el desarrollo de tus aplicaciones de forma local. Para
servir archivos en producción utiliza un servidor dedicado, consulta él capítulo 12,
para conocer algunos servidores que te pueden ayudar en esa tarea.

Usando grupos con nombres 

En las expresiones regulares de Python, la sintaxis para los grupos de expresiones
regulares con nombre es (?P<nombre>patrón), donde nombre es el nombre del grupo
y patrón es algún patrón a buscar.
Ejemplo:
from django.conf.urls import url
from libros import views
urlpatterns = [
url(r'^libros/(\d{4})/$', views.libros_año),
url(r'^libros/(\d{4})/(\d{2})/$', views.libros_mensuales),
url(r'^libros/(\d{4})/(\d{2})/(\d{2})/$', views.libros_diarios),
]
Rescrita para usar grupos con nombres
Ejemplo:
urlpatterns = [
url(r'^libros/(?P<año>\d{4})/$', views.libros_año),
url(r'^libros/(?P<año>\d{4})/(?P<mes>\w{3})/$', views.libros_mes),
url(r'^libros/(?P<año>\d{4})/(?P<mes>\w{3})/(?P<dia>\d{2})/$', views.libros_dia),
]
Por ejemplo, con los grupos sin nombre una petición a /libros/2006/03/ resultaría
en una llamada de función equivalente a esto:
>>>libros_mensuales(request, ’2006’, ’03’)
Sin embargo, con los grupos con nombre, la misma petición resultaría en esta
llamada de función:
>>>libros_mensuales(request, año='2006', mes='03')

Una advertencia al usar grupos con nombre en una URLconf es que un simple
patrón URLconf no puede contener grupos con nombre y sin nombre. Si haces eso,
Django no generará ningún mensaje de error, pero probablemente descubras que tus
URLs no se están disparando de la forma esperada.

El algoritmo de combinación/agrupación

-> Si existe algún argumento con nombre, usará esos, ignorando los argumentos
sin nombre.

-> Además, pasará todos los argumentos sin nombre como argumentos
posicionales.

-> En ambos casos, pasará cualquier opción extra como argumentos de palabra
clave.

Pasarle opciones extra a las funciones vista

Para evitar la repetición de la una funcion vista, el primer acercamiento seria:
-> Pasar dos argumentos a la funcion vista (request,url) donde url seria el nombre 
que se intenta buscar. De esta forma pueden coexistir dos vistas asociadas a una misma funcion vista.
El problema con esto es que tiene un fuerte acoplamiento con la vista.
-> La solucion elegante seria involucrar un parámetro URLconf opcional. Cada patron en la URLconf puede
incluir un tercer ítem: un diccionario de argumentos de palabra clave para pasarle a la funcion vista.

Simulando valores capturados en URLconf

El detalle genial aquí es que no necesitas cambiar tu función vista para nada. A la
función vista sólo le incumbe el obtener los parámetros mes y día -- no importa si los
mismos provienen de la captura de la URL o de parámetros extra.
Ejemplo:
urlpatterns = [
    url(r’^libros/favoritos/$’, views.libros_dia, {’mes’: ’enero’, ’dia’: ’06’}),
    url(r’^libros/(?P<mes>\w{3})/(?P<dia>\d){2}/$’, views.libros_dia),
]   

Convirtiendo una vista en genérica

continuación, un par de notas acerca de lo que hicimos:
-> Estamos pasando las clases de modelos directamente, como el parámetro
model. El diccionario de opciones extra de URLconf puede pasar cualquier
tipo de objetos Python -- no sólo cadenas.
-> La línea model.objects.all() es un ejemplo de tipado de pato (duck typing): ‘‘Si
camina como un pato, y habla como un pato, podemos tratarlo como un
pato.’’ Nota que el código no conoce de qué tipo de objeto se trata model; el 
único requerimiento es que model tenga un atributo objects, el cual a su vez
tiene un método all().
-> Estamos usando model.__name__.lower() para determinar el nombre de la
plantilla. Cada clase Python tiene un atributo __name__ que retorna el
nombre de la clase. Esta característica es útil en momentos como este, cuando
no conocemos el tipo de clase hasta el momento de la ejecución. Por ejemplo,
el __name__ de la clase BlogEntry es la cadena BlogEntry.
-> En una sutil diferencia entre este ejemplo y el ejemplo previo, estamos
pasando a la plantilla el nombre de variable genérico lista_objectos. Podemos
fácilmente cambiar este nombre de variable a lista_libros o lista_editores,
pero hemos dejado eso como un ejercicio para el lector.

Entendiendo la precedencia entre valores capturados vs opciones extra

Cuando se presenta un conflicto, los parámetros extra de la URLconf tienen
precedencia sobre los parámetros capturados. En otras palabras, si tu URLconf
captura una variable de grupo con nombre y un parámetro extra de URLconf incluye
una variable con el mismo nombre, se usará el parámetro extra de la URLconf.

Usando argumentos de vistas por omisión
Veamos un ejemplo:
urls.py
from django.conf.urls import url
from biblioteca import views
urlpatterns = [
    (r’^libros/$’, views.pagina),
    (r’^libros/pagina(?P<num>\d+)/$’, views.pagina),
]
views.py
def pagina(request, num=’1’):
# La salida

Manejando vista en forma especial
Ejemplo
urlpatterns = [
# ...
    url(’^auth/user/add/$’, views.user_add_stage),
    url(’^([^/]+)/([^/]+)/add/$’, views.add_stage),
# ...
]
Con esto, una petición a /auth/user/add/ será manejada por la vista
user_add_stage. Aunque dicha URL coincide con el segundo patrón, coincide
primero con el patrón ubicado más arriba. (Esto es lógica de corto circuito).
Esto es porque las url se procesan de arriba hacia abajo.

Capturando texto en URLs

El texto capturado debe ser convertido al tipo de dato que se requiera en la 
url.

Entendiendo  dónde busca una URLconf

Cuando llega una petición, Django intenta comparar los patrones de la URLconf con
la URL solicitada como una cadena Python normal (no como una cadena Unicode).
Esto no incluye los parámetros de GET o POST o el nombre del dominio. Tampoco
incluye la barra inicial porque toda URL tiene una barra inicial.
Por ejemplo, en una petición del tipo http://www.example.com/entrada/ Django
tratará de encontrar una coincidencia para entrada/. En una petición para
http.//www.example.com/entrada/?pagina3 Django tratará de buscar una
coincidencia para entrada/.
El método de la petición (por ejemplo POST, GET, HEAD) no se tiene en cuenta
cuando se recorre la URLconf. En otras palabras, todos los métodos serán
encaminados hacia la misma función para la misma URL. Es responsabilidad de una
función vista manejar de forma distinta en base al método de la petición.

Abstracción de alto nivel en las funciones vista

-> Escribimos una nueva vista, llamada vista_divida(), que delega la
responsabilidad a dos vistas mas basadas en el tipo de petición mediante el
método request.method. Este busca dos argumentos clave, GET y POST, los
cuales deben ser funciones vista. Si request.method es 'GET', entonces se
llama a la vista GET. Si request.method es 'POST', entonces llama a la vista
POST. Si request.method es algo como (HEAD, etc.), o si GET o POST no son
proporcionados a la función, entonces se lanza un error del tipo Http404
(pagina no encontrada).
-> En la URLconf, conectamos /indice/ con vista_divida() y pasamos los
argumentos extras -- la función de vista para usar GET y POST,
respectivamente.
-> Finalmente, separamos la vista vista_divida() en dos funciones --
peticion_get() y peticion_post(). Esto es mucho más agradable que
empaquetar toda la lógica en una simple vista.

Empacando Funciones de Vista
Ejemplo
#views.py
def requiere_login(view):
    def vista_nueva(request, *args, **kwargs):
        if not request.user.is_authenticated():
            return HttpResponseRedirect(’/accounts/login/’)
        return view(request, *args, **kwargs)
    return vista_nueva

#urls.py
from django.conf.urls import urls
from .views import requiere_login, vista1, vista2, vista3
urlpatterns = [
    url(r’^vista1/$’, requiere_login(vista1)),
    url(r’^vista2/$’, requiere_login(vista2)),
    url(r’^vista3/$’, requiere_login(vista3)),
]

Incluyendo otras URLconfs

Existe aquí un detalle importante: en este ejemplo, la expresión regular que apunta
a un include() no tiene un $ (carácter que coincide con un fin de cadena) pero si
incluye una barra al final. Cuando Django encuentra include(), elimina todo el
fragmento de la URL que ya ha coincidido hasta ese momento y envía la cadena
restante a la URLconf incluida para su procesamiento subsecuente.

Otra posibilidad para incluir patrones adicionales en una URL, es usando una lista
de instancias de la url(). Por ejemplo, considera esta URLconf.:

from django.conf.urls import include, url
from apps.main import views as vista_principal
from credito import views as vista_credito
patrones_extra = [
    url(r’^reportes/(?P<id>[09]+)/$’,vista_credito.reportes),
    url(r’^cargos/$’, vista_credito.cargos),
]
urlpatterns = [
    url(r’^$’, vista_principal.indice),
    url(r’^ayuda/’, include(’apps.ayuda.urls’)),
    url(r’^credito/’, include(patrones_extra)),
]
En este ejemplo la URL /credito/reportes/, será manejada por la vista
vista_credito.reportes().

Esto también puede ser usado para remover redundancia en las URLconfs,
mediante un simple prefijo en un patrón usado repetidamente. Por ejemplo,
considera esta URLconf:

from django.conf.urls import include, url
from . import views
urlpatterns = [
    url(r’^(?P<pagina_slug>\w+)(?P<pagina_id>\w+)/’, include([
        url(r’^historia/$’, views.historia),
        url(r’^editar/$’, views.editar),
        url(r’^discusiones/$’, views.discusiones),
        url(r’^permisos/$’, views.permisos),
    ])),
]

Cómo trabajan los parámetros capturados con include()

De manera similar, puedes pasar opciones extra de URLconf a include() así como
puedes pasar opciones extra de URLconf a una vista normal -- como un diccionario.
Cuando haces esto, las opciones extra serán pasadas a todas las líneas en la URLconf
incluida.
Una URLconf incluida recibe todo parámetro que se haya capturado desde las
URLconf padre.

Resolución inversa de URLs

Es altamente recomendable evitar codificar en duro las URLs(ya que esta sería una
estrategia muy laboriosa, propensa a errores y poco escalable) o tener que idear
mecanismos para generar URLs que sean paralelas al diseño descrito por la URLconf,
algo semejante podría echar a perder las URLs en algún punto.
En otras palabras, es necesario usar un mecanismo DRY (no te repitas). Entre otras
ventajas permitiría la evolución del diseño de URL sin tener que explorar en todas
partes del codigo fuente, buscando y remplazando URLs obsoletas.

Django ofrece una solución semejante al mapear una URL, únicamente en un solo
lugar. Solo la defines en la URLconf y entonces puede usarla en ambas direcciones.
Funciona de dos formas:
1. La primera forma comienza con una petición del usuario/navegador, este
llama a la vista correcta de Django y provee cualquier argumento que pueda
necesitar así como los valores extraídos del URL.
2. La segunda forma comienza con la identificación de la vista correspondiente
de Django más los valores de los argumentos que le son pasados, obtenidos de
la URL asociada.

Django proporciona herramientas para optimizar las coincidencias de URL
inversas en las distintas capas donde sean necesarios.
-> En las plantillas: Usando la etiqueta de plantillas url
-> En el código Python: Usando la función django.core.urlresolvers.reverse
-> En código de alto nivel, para relacionar el manejo de URLs de instancias de
modelos: por ejemplo el método get_absolute_url en los modelos.


Capitulo 9. Plantillas avanzadas

-> Las etiquetas de bloque deben ser rodeadas por {% y %}
-> Una variable es un símbolo dentro de una plantilla que emite un valor.
   Las etiquetas de variable deben ser rodeadas por {{ y }}
-> Un contexto es un mapeo entre nombres y valores (similar a un
   diccionario de Python) que es pasado a una plantilla.

Una plantilla renderiza un contexto reemplazando los ‘‘huecos’’ que dejan las
variables por valores tomados del contexto y ejecutando todas las etiquetes de
bloque.

Las peticiones de contexto (RequestContext) y los procesadores de contexto
(Context Processors) fueron creados para resolver este problema. Los procesadores
de contexto te permiten especificar un número de variables que son incluidas
automáticamente en cada contexto -- sin la necesidad de tener que hacerlo 
manualmente en cada llamada a render(). El secreto está en utilizar RequestContext
en lugar de Context cuando renderices una plantilla.
La forma de nivel más bajo de usar procesadores de contexto es crear algunos de
ellos y pasarlos a RequestContext. Ejemplo de uso con render (alto nivel)

from django.shortcuts import render
from django.template import RequestContext
def custom_proc(request):
" Un procesador de contexto que provee ’aplicacion’, ’usuario’ y ’directamente_ip’."
  return {
    ’aplicacion: ’Biblioteca’,
    ’usuario’: request.user,
    ’direccion_ip’: request.META[’REMOTE_ADDR’],
    }
def vista2(request):
# ...
    return render(request, ’plantilla1.html’,
        {’mensaje’: ’Soy la vista 1.’},
            context_instance=RequestContext(request, processors=[custom_proc]))
def vista2(request):
# ...
    return render(request, ’template2.html’,
        {’mensaje’: ’Soy la vista 2.’},
            context_instance=RequestContext(request, processors=[custom_proc]))

Consideraciones para escribir tus propios procesadores de contexto

Algunos puntos a tener en cuenta:
-> Cada procesador de contexto debe ser responsable por la mínima cantidad de
funcionalidad posible. Usar muchos procesadores es algo sencillo, es por eso
que dividir la funcionalidad de tu procesador de manera lógica puede ser útil
para poder reutilizarlos en el futuro.
-> Ten presente que cualquier procesador de contexto en
TEMPLATE_CONTEXT_PROCESSORS estará disponible en cada plantilla cuya
configuración esté dictada por ese archivo de configuración, así que trata de
seleccionar nombres de variables con pocas probabilidades de entrar en
conflicto con nombre de variables que tus plantillas pudieran usar en forma
independiente. Como los nombres de variables son sensibles a
mayúsculas/minúsculas no es una mala idea usar mayúsculas para las
variables provistas por un procesador.
-> No importa dónde residan en el sistema de archivos, mientras se hallen en tu
ruta de Python de manera que puedas incluirlos en tu variable de
configuración TEMPLATE_CONTEXT_PROCESSORS. Habiendo dicho eso,
diremos también que la convención es grabarlos en un archivo llamado
context_processors.py ubicado en tu aplicación o en tu proyecto.

Consideraciones para escribir tus propios procesadores de contexto

-> Cada procesador de contexto debe ser responsable por la mínima cantidad de
funcionalidad posible. Usar muchos procesadores es algo sencillo, es por eso
que dividir la funcionalidad de tu procesador de manera lógica puede ser útil
para poder reutilizarlos en el futuro.
-> Ten presente que cualquier procesador de contexto en
TEMPLATE_CONTEXT_PROCESSORS estará disponible en cada plantilla cuya
configuración esté dictada por ese archivo de configuración, así que trata de
seleccionar nombres de variables con pocas probabilidades de entrar en
conflicto con nombre de variables que tus plantillas pudieran usar en forma
independiente. Como los nombres de variables son sensibles a
mayúsculas/minúsculas no es una mala idea usar mayúsculas para las
variables provistas por un procesador.
-> No importa dónde residan en el sistema de archivos, mientras se hallen en tu
ruta de Python de manera que puedas incluirlos en tu variable de
configuración TEMPLATE_CONTEXT_PROCESSORS. Habiendo dicho eso,
diremos también que la convención es grabarlos en un archivo llamado
context_processors.py ubicado en tu aplicación o en tu proyecto.

Escape automático de HTML

Para evitar este problema, tienes dos opciones:
1. Uno, asegúrate de que cada una de las variables ‘‘no confiables’’, sean pasadas
a través de un filtro escape, el cual convierte caracteres potencialmente
dañinos en no dañinos. Esta fue la solución por defecto en Django durante los
primeros años, pero el problema es que pone toda la responsabilidad en ti que
como desarrollador/autor de plantillas, debes asegurarte de escapar todo. Es
fácil olvidar escapar datos.
2. Dos, puedes tomar ventaja de que Django automáticamente escapa el HTML.
El resto de esta sección describe como trabaja el auto-escape.
Por defecto en Django, cada plantilla se encarga automáticamente de escapar la
salida de cada etiqueta de variable. Es particular estos cinco caracteres son
escapados:
• < es convertido a &lt;
• > es convertido a &gt;
• ' (comillas simples) son convertidas a &#39;
• " (comillas dobles) son convertidas a &quot;
• &  es convertido a &amp;

De nuevo, hacemos énfasis en que este comportamiento se da por defecto. Si estas
usando el sistema de plantillas, estas protegido.

Como desactivar el escape automático

Para desactivar el auto-escape para una variable individual, usa el filtro safe:
• Esto será escapado: {{ datos }}
• Esto no será escapado {{ datos|safe }}

Para bloques de plantillas

Para controlar el auto-escapado de una plantilla, envuelve la plantilla (o solo una
sección en particular) con la etiqueta autoescape, de esta forma:
{% autoescape off %}
    Hola {{ nombre }}
{% endautoescape %}

Escape automático de cadenas literales en argumentos de filtros

{{ datos|default:"Esta es una cadena literal." }}
Todas las cadenas literales son insertadas sin escape automático en la plantilla --
actúan como si fueran pasadas por el filtro safe. La razón detrás de todo esto, es que
los autores de plantillas tienen el control de lo que pasan dentro de las cadenas 
literales, así que se aseguran que el texto sea escapado correctamente cuando la
plantilla es escrita.
Por lo que escribirías
{{ datos default:"3 &lt; 2" }}
En lugar de:
{{ datos default:"3 < 2" }} <--¡ Mal! No hagas esto.

Detalles internos de la carga de plantilla

Django tiene dos maneras de cargar plantillas:
-> django.template.loader.get_template(template): get_template retorna la
plantilla compilada (un objeto Template) para la plantilla con el nombre
provisto. Si la plantilla no existe, se generará una excepción
TemplateDoesNotExist.
-> django.template.loader.select_template(template_nombre_list):
select_template es similar a get-template, excepto que recibe una lista de
nombres de plantillas. Retorna la primera plantilla de dicha lista que existe. Si
ninguna de las plantillas existe se lanzará una excepción
TemplateDoesNotExist.

Estos son los cargadores de plantillas incluidos con Django:
-> django.template.loaders.filesystem.load_template_source: Este cargador
carga plantillas desde el sistema de archivos, de acuerdo a TEMPLATE_DIRS.
Por omisión está activo.
-> django.template.loaders.app_directories.load_template_source: Este
cargador carga plantillas desde aplicaciones Django en el sistema de archivos.
Para cada aplicación en INSTALLED_APPS, el cargador busca un subdirectorio
templates. Si el directorio existe, Django buscará una plantilla en el
mismo.
-> django.template.loaders.eggs.load_template_source: Este cargador es
básicamente idéntico a app_directories, excepto que carga las plantillas desde
eggs Python en lugar de hacerlo desde el sistema de archivos. Por omisión este
cargador está desactivado; necesitarás activarlo si estás usando eggs para
distribuir tu aplicación.

Esto significa que puedes almacenar plantillas en tus aplicaciones individualmente,
facilitando la distribución de aplicaciones Django con plantillas predeterminadas.
Por ejemplo si INSTALLED_APPS contiene ('misitio.blog', 'misitio.musica') entonces
get_template('foo.html') buscará plantillas en el siguiente orden:
1. /ruta/a/misitio/blog/templates/foo.html
2. /ruta/a/misitio/musica/templates/foo.html

Extender el sistema de plantillas

Crear una biblioteca de etiquetas 
Ya sea que estés escribiendo etiquetas o filtros personalizados, la primera tarea a
realizar es crear una biblioteca para etiquetas -- un pequeño fragmento de
infraestructura con el cual Django puede interactuar (un directorio).
La creación de una biblioteca para etiquetas es un proceso de dos pasos:
-> Primero, decidir qué aplicación Django alojará el directorio. Si has creado una
aplicación vía manage.py startapp puedes colocarla allí, o puedes crear otra
aplicación con el solo fin de alojar la biblioteca.
Sin importar cuál de las dos rutas tomes, asegúrate de agregar la aplicación a
tu variable de configuración INSTALLED_APPS. Explicaremos esto un poco
más adelante.
-> Segundo, crea un directorio templatestags en el paquete de aplicación Django
apropiado. Debe encontrarse en el mismo nivel que models.py, views.py, etc.
Crea dos archivos vacíos en el directorio templatetags: un archivo __init__.py
(para indicarle a Python que se trata de un paquete que contiene código
Python) y un archivo que contendrá tus definiciones personalizadas de
etiquetas/filtros. El nombre del segundo archivo es el que usarás para cargar
las etiquetas más tarde. Por ejemplo, si tus etiquetas/filtros personalizadas
están en un archivo llamado etiquetas.py, entonces deberás escribir lo
siguiente en una plantilla:
{% load etiquetas %}

La etiqueta {% load %} examina tu variable de configuración
INSTALLED_APPS y sólo permite la carga de bibliotecas para plantillas desde
aplicaciones Django que estén instaladas. Se trata de una característica de
seguridad; te permite tener en cierto equipo el código Python de varias
bibliotecas para plantillas sin tener que activar el acceso a todas ellas para
cada instalación de Django.

Si escribes una biblioteca para etiquetas que no se encuentra atada a ningún
modelo/vista particular es válido y normal el tener un paquete de aplicación Django
que sólo contiene un paquete templatetags. No existen límites en lo referente a
cuántos módulos puedes poner en el paquete templatetags. Sólo ten presente que
una sentencia {% load %} cargará etiquetas/filtros para el nombre del módulo Python
provisto, no el nombre de la aplicación.
Una vez que has creado ese módulo Python, sólo tendrás que escribir un poquito
de código Python, dependiendo de si estás escribiendo filtros o etiquetas.
Para ser una biblioteca de etiquetas válida, el módulo debe contener una variable a
nivel del módulo llamada register, que sea una instancia de template.Library. Esta
instancia de template.Library es la estructura de datos en la cual son registrados
todas las etiquetas y filtros.

Escribir filtros de plantilla personalizados

Los filtros personalizados son sólo funciones Python que reciben uno o dos
argumentos:
-> El valor de la variable (entrada)
-> El valor del argumento, el cual puede tener un valor por omisión o puede ser
obviado.

Las funciones filtro deben siempre retornar algo. No deben arrojar excepciones, y
deben fallar silenciosamente. Si existe un error, las mismas deben retornar la entrada
original o una cadena vacía, dependiendo de qué sea más apropiado.

Escribir etiquetas de plantilla personalizadas
Escribir la función de compilacion
Ejemplo:
<p>La fecha actual es {% fecha_actual "%Y-%m-%d %I:%M %p" %}.</p>

Argumentos de la funcion de compilación
-> parser es la instancia del parser. No lo necesitamos en este ejemplo.
-> token.contents es un cadena con los contenidos crudos de la etiqueta, en
nuestro ejemplo sería: ‘fecha_actual ‘‘%Y-%m-%d %I:%M %p’’’.
-> El método token.split_contents() separa los argumentos en sus espacios,
mientras deja unidas a las cadenas. Evite utilizar token.contents.split() (el cual
usa la semántica natural de Python para dividir cadenas, y por esto no es tan
robusto, ya que divide en todos los espacios, incluyendo aquellos dentro de
cadenas entre comillas.
-> Esta función es la responsable de generar la excepción
django.template.TemplateSyntaxError con mensajes útiles, ante cualquier
caso de error de sintaxis.
-> No escribas el nombre de la etiqueta en el mensaje de error, ya que eso
acoplaría innecesariamente el nombre de la etiqueta a la función. En cambio,
token.split_contents()[0] siempre contendrá el nombre de tu etiqueta -- aún
cuando la etiqueta no lleve argumentos.
-> La función devuelve NodoFechaActual (el cual mostraremos en un momento)
conteniendo todo lo que el nodo necesita saber sobre esta etiqueta. En este
caso, sólo pasa el argumento "%Y-%m-%d %I:%M %p". Las comillas son
removidas con format_string[1:-1].
-> Las funciones de compilación de etiquetas de plantilla deben devolver una
subclase de Node; cualquier otro valor es un error.

Definir una variable en el contexto

El ejemplo en la sección anterior simplemente devuelve un valor. Muchas veces es
útil definir variables de plantilla en vez de simplemente devolver valores. De esta
manera, los autores de plantillas podrán directamente utilizar las variables que esta
etiqueta defina.
Para definir una variable en el contexto, asignaremos a nuestro objeto context
disponible en el método render() nuestras variables, como si de un diccionario se
tratase.

Pero hay un problema con NodoFechaActual2: el nombre de la variable
fecha_actual está definido dentro del código. Esto significa que tendrás que asegurar
que {{ fecha_actual }} no sea utilizado en otro lugar dentro de la plantilla, ya que {%
fecha_actual %} sobreescribirá el valor de esa otra variable.

Evaluar hasta otra etiqueta de bloque

Las etiquetas de plantilla pueden funcionar como bloques que contienen otras
etiquetas (piensa en {% if %}, {% for %}, etc.). Para crear una etiqueta como esta, usa
parser.parse() en tu función de compilación.

parser.parse() toma una tupla de nombres de etiquetas de bloque para evaluar y
devuelve una instancia de django.template.NodeList, la cual es una lista de todos los
objetos Nodo que el parser encontró antes de haber encontrado alguna de las
etiquetas nombradas en la tupla.
Entonces, en el ejemplo previo, nodelist es una lista con todos los nodos entre
{% comment %} y {% endcomment %}, excluyendo a los mismos {% comment %} y {%
endcomment %}.
Luego de que parser.parse() es llamado el parser aún no ha ‘‘consumido’’ la
etiqueta {% endcomment %}, es por eso que en el código se necesita llamar
explícitamente a parser.delete_first_token() para prevenir que esta etiqueta sea
procesada nuevamente.
Luego, CommentNode.render() simplemente devuelve un string vacío. Cualquier
cosa entre {% comment %} y {% endcomment %} es ignorada.

Evaluar hasta otra etiqueta de bloque y guardar el contenido

En el ejemplo anterior, do_comment() desechó todo entre {% comment %} y
{% endcomment %}, pero también es posible hacer algo con el código entre estas
etiquetas.
Por ejemplo, presentamos una etiqueta de plantilla, {% upper %}, que convertirá a
mayúsculas todo hasta la etiqueta {% endupper %} 

Un atajo para etiquetas simples

Para facilitar la creación de esos tipos de etiquetas, Django provee una función
auxiliar: simple_tag. Esta función, que es un método de django.template.Library,
recibe una función que acepta un argumento, lo encapsula en una función render y el
resto de las piezas necesarias que mencionamos previamente y lo registra con el
sistema de plantillas.

Un par de cosas a tener en cuenta acerca de la función auxiliar simple_tag:
-> Sólo se pasa un argumento a nuestra función.
-> La verificación de la cantidad requerida de argumentos ya ha sido realizada
para el momento en el que nuestra función es llamada, de manera que no es
necesario que lo hagamos nosotros.
-> Las comillas alrededor del argumento (si existieran) ya han sido quitadas, de
manera que recibimos una cadena común.

Etiquetas de inclusión

Ese tipo de etiquetas reciben el nombre de etiquetas de inclusión. Es
probablemente mejor demostrar cómo escribir una usando un ejemplo. Escribamos
una etiqueta que produzca una lista de libros para un simple objeto Libro. Usaremos
una etiqueta como esta:
{% libros_por_autor autor %}

Como siempre, la sintaxis de decoradores de Python también funciona, de manera
que podemos haber escrito:
@register.inclusion_tag('libros_por_autor.html')
def libros_por_autor(autor):
    ....

A veces tus etiquetas de inclusión necesitan tener acceso a valores del contexto de
la plantilla padre. Para resolver esto Django provee una opción takes_context para las
etiquetas de inclusión. Si especificas takes_context cuando creas una etiqueta de
plantilla, la misma no tendrá argumentos obligatorios y la función Python
subyacente tendrá un argumento: el contexto de la plantilla en el estado en el que se
encontraba cuando la etiqueta fue invocada.

Escribir cargadores de plantillas personalizados

Un cargador de plantillas --esto es, cada entrada en la variables de configuración
TEMPLATE_LOADERS-- debe ser un objeto invocable (callable) con la siguiente
interfaz: load_template_source(template_nombre, template_dirs=None)
El argumento template_nombre es el nombre de la plantilla a cargar (tal como fue
pasado a loader.get_template() o loader.select_template()) y template_dirs es una
lista opcional de directorios en los que se buscará en lugar de TEMPLATE_DIRS.
Si al cargador no le es posible cargar una plantilla, debe lanzar
django.template.TemplateDoesNotExist.

El único paso restante si deseamos usar este cargador es agregarlo a la variable de
configuración TEMPLATE_LOADERS. Si pusiéramos este código en un paquete
llamado misitio.zip_loader entonces agregariamos
misitio.zip_loader.load_template_source a TEMPLATE_LOADERS.

Usar la referencia de plantillas incorporadas

La interfaz de administración de Django incluye una referencia completa de todas las
etiquetas y filtros de plantillas disponibles para un sitio determinado. Está designada
para ser una herramienta que los programadores Django proveen a los
desarrolladores de plantillas. Para activarla sigue los siguientes pasos:
-> Agrega la aplicación 'django.contrib.admindocs' al archivo settings.py en la
variable INSTALLED_APPS (como lo harías con cualquier otra aplicación).
-> Agrega el patrón, (r'^admin/doc/', include('django.contrib.admindocs.urls'))
al archivo urls.py, solo asegúrate que aparezca antes que el patrón que apunta
a la interfaz administrativa (r'^admin/')
-> Dirige tu navegador a: /admin/doc/.

La página views es la más valiosa. Cada URL en tu sitio tiene allí una entrada
separada. Si la vista relacionada incluye una cadena de documentación o docstring,
haciendo clic en la URL te mostrará lo siguiente:
-> El nombre de la función de vista que genera esa vista.
-> Una breve descripción de lo qué hace la vista.
-> El contexto, o una lista de variables disponibles en la plantilla de la vista.
-> El nombre de la plantilla o plantillas usados para esa vista.

Configurando el sistema de plantillas en modo autónomo

Nota: Estas sección es sólo de interés para aquellos que intentan usar el sistema
de plantillas como un componente de salida en otra aplicación. Si estás usando el
sistema como parte de una aplicación Django, la información aquí presentada no es
relevante para ti.

Normalmente Django carga toda la información de configuración que necesita
desde su propio archivo de configuración por omisión, combinado con las variables
de configuración en el módulo indicado en la variable de entorno
DJANGO_SETTINGS_MODULE. Pero si estás usando el sistema de plantillas
independientemente del resto de Django, el esquema de la variable de entorno no es
muy conveniente porque probablemente quieras configurar el sistema de plantillas
en una manera más acorde con el resto de tu aplicación en lugar de tener que vértelas
con archivos de configuración e indicando los mismos con variables de entorno.
Para resolver este problema necesitas usar la opción de configuración manual
descrita en forma completa en el Apéndice E. En resumen, necesitas importar las
partes apropiadas del sistema de plantillas y entonces, antes de invocar alguna de las
funciones de plantillas, invoca a django.conf.settings.configure() con cualquier valor
de configuración que desees especificar.


Cap_10. Modelos avanzados
Accediendo a valores en claves foráneas

Cuando accedes a un campo del tipo ForeignKey (Relación foránea, del tipo muchos
a uno)
Puedes obtener el modelo del objeto relacionado, de la siguiente forma:
>>> from biblioteca.models import Editor, Libro
>>> b = Libro.objects.get(id=5)
>>> b.editor
<Publisher: Apress Publishing>
>>> b.editor.website
u'http://www.apress.com/'

Accediendo a valores en claves muchos a muchos

Los valores muchos a muchos (Many-to-many) trabajan de forma parecida a los
valores en campos foráneos, a menos que tratemos con valores QuerySet en lugar de
instancias del modelo. Por ejemplo, este es la forma que se muestran los autores de
un libro:
>>> b = Libro.objects.get(id=5)
>>> b.autores.all()
[<Author: Adrian Holovaty>, <Author: Jacob KaplanMoss>]
>>> b.autores.filter(nombre='Adrian')
[<Author: Adrian Holovaty>]
>>> b.autores.filter(nombre='Adam')

Esto también trabaja en orden inverso, Para visualizar todos los libros de un
determinado autor, usa autor.libro_set, así:
>>> from biblioteca.models import Autor
>>> a = Autor.objects.get(nombre='Adrian', apellidos='Holovaty')
>>> a.libro_set.all()
[<Libro: The Django Libro>, <Libro: Adrian's Other Libro>]

Como realizar cambios al esquema de la base de datos

Cuando se trata con cambios al esquema de la base de datos, es importante tener
en cuenta algunas cuestiones relacionadas con la forma en que trabaja la capa de
base de datos de Django:
-> Django se quejará estrepitosamente si un modelo contiene un campo que
todavía no se ha creado en la tabla de base de datos. Esto causará un error la
primera vez que utilices la API de la base de datos (es decir, esto sucede en
tiempos de ejecución del código, no en tiempos de compilación).
-> A Django no le importa si una tabla de la base de datos, contiene columnas
que no están definidas en el modelo.
-> A Django no le importa si una base de datos contiene una tabla que no está
representada por un modelo.

Migraciones

Los dos comandos que se encargan de interactuar con las migraciones y manejar el
esquema de la base de datos en Django son:
-> makemigrations: Comando responsable de crear nuevas migraciones
basadas en los cambios hechos a los modelos.
-> migrate: Comando responsable de aplicar las migraciones y
sincronizar los modelos de la base de datos y listar su
estatus.

Agregar campos

Para agregar campos a un modelo sigue estos pasos:
1. Agrega el campo a tu modelo.
2. Asegúrate que el campo incluya las opciones blank=True o null=True (si es un
campo basado en fechas o numérico).
3. Ejecuta el comando manage.py makemigrations, para grabar los cambios.
4. Sincroniza los modelos con manage.py migrate.
5. Ejecuta manage.py shell y verifica que el nuevo campo se haya agregado
correctamente, importa el modelo y realiza una consulta a la base de datos
(por ejemplo con Libro.objects.all()[:5]). Si la actualización fue correcta, la
declaración anterior debe trabajar sin errores.

Una vez que hemos cambiado nuestro modelo, podemos validarlo usando el
comando python manage.py check, para asegurarnos de que todo está correctamente
en su lugar, si el comando no lanza ningún error, podemos crear las migraciones con
el comando python manage.py makemigrations.

Asegúrate de leer la salida para ver lo qué el comando makemigrations piensa
que ha cambiado -- no es perfecto, sobre todo en cambios complejos, puede ser que
no detecte lo que esperabas.

Eliminar campos

1. Remueve el campo de tu modelo.
2. Ejecuta el comando python manage.py makemigrations, para grabar los
cambios.
3. Haz los cambios en la base de datos con el comando python
manage.py migrate.
4. Y reinicia el servidor Web.

Eliminar relaciones muchos a muchos

Para eliminar manualmente una relación muchos a muchos, tendríamos que hacer
lo siguiente:
1. Remueve el campo ManyToManyField de tu modelo y reinicia el servidor
Web.
2. Remueve la tabla muchos a muchos de tu base de datos usando un comando
SQL como este:
DROP TABLE libros_libro_autores;

Como en la sección anterior, podemos seguir los siguientes pasos, para usar las
migraciones:
1. Remueve el campo muchos a muchos de tu modelo.
2. Ejecuta el comando python manage.py makemigrations, para grabar los
cambios.
3. Haz los cambios en la base de datos con el comando python
manage.py migrate.
4. Reinicia el servidor Web.

Eliminar modelos

Eliminar un modelo completo es tan fácil como agregar uno. Para remover un
modelo, solo sigue estos pasos:
1. Remueve el modelo.
2. Ejecuta el comando python manage.py makemigrations, para grabar los
cambios.
3. Haz los cambios en la base de datos con el comando python
manage.py migrate.
4. Reinicia el servidor Web.
Manualmente puedes hacerlo así:
1. Elimina el modelo de tu archivo models.py y reinicia el servidor.
2. Elimina la tabla de tu base de datos, usando el siguiente comando:
DROP TABLE biblioteca_libro;

Advertencia: Ten en cuenta, que también es necesario remover cualquier tabla
que dependa de el modelo que quieras borrar de tu base de datos primero --por
ejemplos alguna tabla que contenga un campo foráneo o una relación muchos a
muchos.

Manejadores o Managers

Un Manager es la interfaz a través de la cual se proveen las operaciones de consulta
de la base de datos a los modelos de Django. Existe al menos un Manager para cada
modelo en una aplicación Django.

Nombres de Manager

Para renombrar el Manager para una clase dada, define un
atributo de clase de tipo models.Manager() en ese modelo, por ejemplo:
from django.db import models
class Persona(models.Model):
...#
    gente = models.Manager()

Agregando Métodos Extra al Manager

Por ejemplo, démosle al Manager de nuestro modelo Libro un método
contar_titulos(), el cual toma una palabra clave y retorna el número de libros que
contienen un titulo que contiene dicha palabra. (Este ejemplo es bastante superficial,
pero demuestra cómo trabajan los Managers)

Algunas notas sobre el código:
-> Creamos una clase ManejadorLibros que extiende a la clase
django.db.models.Manager. El sencillo método contar_titulos(), hace los
cálculos. Observa que el método usa un filtro self.filter(), donde self se refiere
al manager en sí mismo.
-> Asignamos ManejadorLibros() a los atributos de objects en el modelo. Esto
tiene el efecto de reemplazar el manejado por ‘‘defecto’’, el cual es llamado
objects y es automáticamente creado si no especificas un manager
personalizado. Lo hemos llamado objects en vez de usar algún otro nombre,
para ser consistentes con los managers automáticamente creados por Django.

Otra cosa a observar en este ejemplo es que los métodos de un Manager pueden
acceder a self.model para obtener la clase modelo a la cual están anexados.

Modificando los QuerySets iníciales del Manager

Puedes sobrescribir el QuerySet base, sobrescribiendo el método
Manager.get_query_set(). get_query_set() debe retornar un QuerySet con las
propiedades que tu requieres.

Si usas objetos Manager personalizados, toma nota que el primer Manager que
encuentre Django (en el orden en el que están definidos en el modelo) tiene un status
especial. Django interpreta el primer Manager definido en una clase como el
Manager por omisión. Ciertas operaciones -- como las del sitio de administración de
Django -- usan el Manager por omisión para obtener listas de objetos, por lo que
generalmente es una buena idea que el primer Manager esté relativamente sin filtrar.
En el último ejemplo, el manager gente está definido primero -- por lo cual es el
Manager por omisión.

En resumen, Un Manager es la interfaz a través de la cual se proveen las
operaciones de consulta de la base de datos a los modelos de Django. Existe al menos
un Manager para cada modelo en una aplicación Django. Puedes crear manejadores
personalizados para modificar el acceso a la base de datos para requisitos
particulares.

Metodos de un Modelo 

Define métodos personalizados en un modelo para agregar funcionalidad
personalizada a nivel de registro para tus objetos. Mientras que los métodos Manager
están pensados para hacer cosas a nivel de tabla, los métodos de modelo deben
actuar en una instancia particular del modelo.

__unicode__

El método __unicode__() es un ‘‘método mágico’’ de Python que define lo que debe
ser devuelto si llamas a unicode() sobre el objeto. Django usa unicode(obj) (o la
función relacionada str(obj) que se describe más abajo) en varios lugares,
particularmente como el valor mostrado para hacer el render de un objeto en el sitio
de administración de Django y como el valor insertado en un plantilla cuando
muestra un objeto. Por eso, siempre debes retornar un string agradable y legible por
humanos en el formato __unicode__() de un objeto. A pesar de que esto no es
requerido, es altamente recomendado, sobre todo usando Python2X.

__str__

__str__() es un ‘‘método mágico’’ de Python que define lo que debe ser devuelto si
llamas a str(). En Python3, Django usa str(obj), en varios lugares, particularmente
como el valor mostrado para hacer el render de un objeto en el sitio de
administración de Django y como el valor insertado en un plantilla cuando muestra
un objeto. Por eso, siempre debes retornar un string agradable y legible por humanos
en el __str__ de un objeto. A pesar de que esto no es requerido, es altamente
recomendado, al usar Python3.

__eq__

Un método de igualdad que es definido cuando las instancias con la misma clave
primaria son evaluadas y la clase en concreto es considerada igual.

__hash__

Calcula el valor hash para una clave primaria de cualquier campo.
El método __hash__ está basado en la instancia del valor de la clave primaria.
Usando (obj.pk). Si la instancia no tiene una clave primaria lanzara un error
TypeError.

get_absolute_url

Define un método get_absolute_url() para decirle a Django cómo calcular la URL de
un objeto. Django usa esto en la interfaz de administración. Si un objeto define
get_absolute_url(), la página de edición del objeto tendrá un enlace ‘‘View on site’’,
que te llevará directamente a la vista pública del objeto, según get_absolute_url().
Sin embargo, a pesar de que este código es simple, no es muy portable, por lo que
la mejor forma de aprovechar esto es usando la función reverse().

Advertencia: Debes evitar en lo posible, construir URL para entradas no validas,
para reducir las posibilidades de enlazar contenidos y redireccionamientos no
deseados y potencialmente peligrosos, por ejemplo:
def get_absolute_url(self):
    return '/%s/' % self.nombre
Si self.nombre es '/example.com' este devolverá '//example.com/' el cual es un
esquema URL valido, pero no esperado.

Es una buena práctica usar get_absolute_url() en plantillas, en lugar de codificar en
duro las URL de tus objetos. Por ejemplo, este código de plantilla es malo:
<!– MALO ¡No hagas esto! –> <a href=”/gente/{{ object.id }}/”>{{ object.nombre }}</a>
Pero este es bueno:
<a href=”{{ object.get_absolute_url }}”>{{ object.nombre }}</a>
La lógica aquí, es que puedes cambiar la estructura completa, de las URL de tus
objetos, en un único lugar con get_absolute_url().

Nota: La cadena que devuelve el método get_absolute_url() deve contener
únicamente caracteres ASCII (requeridos por las especificaciones URI RFC 2396) y
deben ser encodificadas de ser necesario (Django provee filtros para esto).
Puedes usar la función django.utils.encoding.iri_to_uri() para realizar este trabajo
y así garantizar que tus cadenas únicamente contendrán caracteres dentro del rango
ASCII.

Sobrescribir métodos predefinidos de un modelo

from django.db import models
class Autor(models.Model):
    nombre = models.CharField(max_length=30)
    apellidos = models.CharField(max_length=40)
    email = models.EmailField()

    Ejemplo
    def save(self, *args, **kwargs):
        haz_algo()
        super(Autor, self).save(*args, **kwargs) # Llama al "verdadero" método save().

    Ejemplo
    def save(self, *args, **kwargs):
        if self.nombre == "Foo":
            return # ¡Foo ha dicho que nunca publicara un libro!
        else:
            super(Autor, self).save(*args, **kwargs) # Llama al "verdadero" método save()

Es también importante pasar los argumentos que se pueda necesitar pasar al
método del modelo - que son *args, **kwargs. De vez en cuando en Django, se
amplían las capacidades incorporados de los métodos de los modelos, agregando
nuevos argumentos. Si utilizas *args y **kwargs en tus definiciones del método,
garantizas que tu código soportará automáticamente esos argumentos cuando se
agreguen mas.

Ejecutando consultas personalizadas en SQL

connection y cursor implementan en su mayor parte la API de bases de datos
estándar de Python, visita  http://www.python.org/peps/pep-0249.html, si no
estás familiarizado con la API de bases de datos de Python, observa que la sentencia
SQL en cursor.execute() usa marcadores de posición, "%s", en lugar de agregar los
parámetros directamente dentro del SQL. Si usas esta técnica, la biblioteca
subyacente de base de datos automáticamente agregará comillas y secuencias de
escape a tus parámetros según sea necesario. (Observa también que Django espera el
marcador de posición "%s", no el marcadores de posición "?", que es utilizado por los
enlaces de Python a SQLite (Python bindings) Esto es por consistencia y salud
mental. En vez de ensuciar el código de tu vista con esta declaración
django.db.connection, es una buena idea ponerlo en un método personalizado en el
modelo o en un método de un manager.

Nota: para ver toda la base de datos SELECT * FROM sqlite_master WHERE type = "table";
las tablas en django tienen primero el nombre de la aplicacion y seguido el de la tabla
asociada al modelo ejemplo app => biblioteca tabla => biblioteca_libro;

Capitulo 11. Vistas genericas

Django viene con vistas genéricas, basadas en clases para hacer lo siguiente:
-> Realizar tareas ‘‘sencillas’’ y comunes: como redirigir a una página diferente a
un usuario y renderizar una plantilla dada.
-> Mostrar páginas de ‘‘listado’’ y ‘‘detalle’’ para un solo objeto. Por ejemplo una
vista para presentar una lista de libros y una para presentar los detalles de un
libro en especifico, la primera es una vista de listado, una página de objetos
simples que muestra la lista de determinado modelo, mientras el segundo es
un ejemplo de lo que llamamos vista ‘‘detallada’’.
-> Presentar objetos basados en fechas en páginas de archivo de tipo
día/mes/año, su detalle asociado, y las páginas ‘‘más recientes’’. Los archivos
por día, mes, año del blog de Django http://www.djangoproject.com/weblog/
están construidos con ellas, como lo estarían los típicos archivos de un
periódico.
-> Permitir a los usuarios crear, actualizar y borrar objetos -- con o sin
autorización.

Introducción a las clases genéricas

Ventajas respecto a las vistas basadas en funciones:
-> Organizan el código relacionado en métodos específicos HTTP (GET, POST,
etc) para que puedan ser tratados por métodos específicos en lugar de tener
que tratar cada uno por separado.
-> Usan la técnica de orientación a objetos para crear ‘‘mixins’’ (herencia
múltiple) que puede ser usada para factorizar el código en componentes
comunes y reutilizables.

Usando vistas basadas en clases

En su núcleo, una vista basada en una clase-base permite responder a diferentes
métodos de petición HTTP, con diversos métodos de la instancia de una clase, en
lugar de condicionalmente ramificar el código dentro de una simple función de vista.

Debido a que el resolvedor de URL de Django espera enviar la petición y los
argumentos asociados a una función llamable no a una clase, la vistas basadas en
clases provén un método interno llamado as_view(), que sirve como punto de
entrada para enlazar la clase a la URL. El punto de entrada as_view() crea una
instancia de la clase y llama al método dispatch(), (el despachador o resolvedor de
URL) que busca la petición para determinar si es un GET, POST, etc, y releva la
petición a un método que coincida con uno definido, o levante una excepción
HttpResponseNotAllowed si no encuentra coincidencias.

Hay dos maneras de
configurar los atributos de una clase.
1. El primero está basado en la forma estándar de Python de sobrescribir
atributos y métodos en las subclases.
2. La segunda opción es configurar los atributos de la clase como argumentos
clave para el método as_view de django.views.generic.base.View.as_view,
llamándolos en la URLconf.

Nota: Mientras que una clase es instanciada en cada petición enviada a ella, los
atributos de la clase fijados a través del punto de entrada del método as_view () se
configuran solamente una vez; cuando se importa la URLs.

Vista Base

Estas tres clases: View, TemplateView y RedirectView proveen muchas de las
funcionalidades necesarias para crear vistas genéricas en Django. Puedes pensar en
ellas como si fueran vista padre o superclases, las cuales pueden ser usadas en sí
mismo o heredar de ellas.

Muchas de las vistas construidas sobre clases basadas en vistas, heredan de otras
vistas genéricas también basadas en clases o de varios mixins. Debido a que esta
cadena de herencia es muy importante, el manejo de ancestros de una clases se
denomina (MRO). MRO por sus siglas en ingles para Method Resolution Orden, se
encarga de resolver el orden que siguen los métodos en una clase.

View

View es la clase base maestra, las demás vistas heredan de esta clase base, que
pertenece al paquete class django.views.generic.base.View.
Flujo de los métodos:
1. dispatch(): El resolvedor de URL´s de la vista -- es decir el método que valida
el argumento de la petición, más los argumentos recibidos y devuelve la
respuesta correcta HTTP.
Por defecto es la implementación que inspecciona el método HTTP y
tentativamente la delega al método que coincida con la petición HTTP; por
ejemplo una petición GET será delegado a un método get(), un POST a un
post(), y así sucesivamente.
2. http_method_not_allowed(): Si la vista es llamada con un método HTTP no
soportado, este método es llamado en su lugar.
La implementación por defecto retorna un HttpResponseNotAllowed con una
lista de métodos permitidos en texto plano.
3. options(): Manejadores que responden a las peticiones OPTIONS HTTP.
Retorna una lista de nombres permitidos al método HTTP para la vista

Por defecto la lista de nombres de métodos HTTP que la vista `View puede aceptar
son: 'get', 'post', 'put', 'patch', 'delete', 'head', 'options', 'trace'.

TemplateView

Ancestros (MRO)
Esta vista hereda atributos y métodos de las siguientes vistas:
-> django.views.generic.base.TemplateResponseMixin
-> django.views.generic.base.ContextMixin
-> django.views.generic.base.View

Flujo de los métodos:
1. dispatch(): Valida la petición (ver arriba).
2. http_method_not_allowed(): Verifica los métodos soportados.
3. get_context_data(): Se encarga de pasarle el contexto (context) a la vista.

RedirectView

La clase RedirectView tal como su nombre lo indica, simplemente redirecciona una
vista con la URL dada.
La URL dada puede contener un formato de estilo tipo diccionario, que será
intercalado contra los parámetros capturados en la URL. Ya que el intercalado de
palabras claves se hace siempre (incluso si no se le pasan argumentos), por lo que
cualquier carácter como "%" (un marcador de posición en Python) en la URL debe
ser escrito como %%" de modo que Python lo convierta en un simple signo de
porcentaje en la salida.

Flujo de los métodos:
1. dispatch()
2. http_method_not_allowed()
3. get_redirect_url(): Construye el URL del objetivo para el redireccionamiento.
La implementación por defecto usa la url como la cadena de inicio para
realizar la expansión mediante el marcador de posición % en la cadena
usando el grupo de nombres capturados en la URL.

Si no se configura el atributo url, mediante el método get_redirect_url()
entonces Django intenta invertir el nombre del patrón, usando los
argumentos capturados en la URL (usando los grupos con y sin nombre).

Si es una petición de un atributo query_string también se agregara a la cadena de
consulta generada por la URL. Las subclases pueden ejecutar cualquier
comportamiento que deseen, mientras que el método devuelva una cadena de
redireccionamiento a una URL.

Los atributos de esta clase son:
-> url: La URL para redireccionar la vista, en formato de cadena o un valor None
para lanzar un error HTTP 410.
-> pattern_name:El nombre de el patrón URL para redirecionar la vista. El
redireccionamiento puede ser hecho usando los mismos args y kwargs que se
pasan a las vistas.
-> permanent: Se usa solo si el redireccionamiento debe ser permanente. La
única diferencia aquí es el código de estado devuelto por la petición HTTP. Si
es True, entonces el redireccionamiento utiliza el código de estado 301. Si es
False, entonces el redireccionamiento utiliza el código de estado 302. Por
defecto, permanent es True.
-> query_string:Cualquier cosa que se le pase a la consulta usando el método
GET a la nueva localización. Si es True, entonces la consulta se añade al final
de la URL. Si es False, entonces la consulta se desecha. Por defecto,
query_string es False.

Vistas genéricas basadas en clases usando URLconfs

La manera más simple de utilizar las vistas genéricas es creándolas directamente en
la URLconf. Si únicamente quieres cambiar algunos atributos en una vista basada en
clases-base, puedes simplemente pasarle los atributos que quieres sobrescribir
dentro del método as_view, ya que este es un llamable en sí mismo.

Vistas genéricas basadas en clases usando subclases

La segunda forma más poderosa de usar las vistas genéricas es hacer que estas
hereden de una vista sobrescribiendo sus atributos (tal como el nombre de la
plantilla) o sus métodos (como get_context_data ) en una subclase que proporcione
nuevos valores o métodos.

Vistas genéricas de objetos

La vista genérica TemplateView ciertamente es útil, pero las vistas genéricas de
Django brillan realmente cuando se trata de presentar vistas del contenido de tu base
de datos. Ya que es una tarea tan común, Django viene con un puñado de vistas
genéricas incluidas que hacen la generación de vistas de listado y detalle de objetos
increíblemente fácil.

Como puedes ver la clase ListView pertenece a la clase
django.views.generic.list.ListView la cual se encarga de presentar un listado de todos
los objetos de un modelo, piensa en ListView como una consulta del tipo
Editor.objets.all(). Cuando esta vista es ejecutada llama al método self.object_list el
cual contiene una lista de objetos (usualmente, pero no necesariamente un queryset)
Después importamos la vista y la enlazamos directamente a la urls, usando el
método as_view(), es como decirle a Django: esta clase es una vista.

Ese es todo el código Python que necesitamos escribir, para presentar un listado
de objetos de un modelo. Sin embargo, todavía necesitamos escribir una plantilla.
Podríamos decirle explícitamente a la vista que plantilla debe usar incluyendo un
atributo template_name, pero en la ausencia de una plantilla explícita Django inferirá
una del nombre del objeto. En este caso, la plantilla inferida será
"biblioteca/editor_list.html" -- la parte ‘‘biblioteca’’ proviene del nombre de la
aplicación que define el modelo, mientras que la parte ‘‘editor’’ es sólo la versión en
minúsculas del nombre del modelo, mas el sufijo _list.

Ciertamente obtener una lista de objetos con la clase genérica ListView es siempre
muy útil, pero que pasa si queremos mostrar un solo objeto, por ejemplo los detalles
de un determinado editor, en ese caso usamos la vista genérica DetailView, que se
encarga de presentar los detalles de un objeto, ejecutando self.object el cual
contendrá el objeto sobre el que la vista está operando.

Nota: Accedemos al contexto usando el nombre en minúsculas del modelo.

Extender las vistas genéricas
Crear contextos de plantilla “amistosos”

Si el nombre no es una buena idea, puedes manualmente cambiarlo en el contexto
de la variable. El atributo context_object_name en una vista genérica específica el
contexto de las variables a usar.

Agregar un contexto extra

La respuesta está en la misma clase DetailView, que provee su propia
implementación del método get_context_data, la implementación por defecto
simplemente agrega un objeto para mostrar en la plantilla, pero puede sobrescribirse
aun más.

Nota: Por lo general get_context_data combina los datos del contexto de todas las
clases padres con los de la clase actual. Para conservar este comportamiento en las
clases donde se quiera alterar el comportamiento del contexto, asegúrate de llamar a
get_context_data en la súper clase. Cuando ninguna de las dos clases trate de definir
la misma clave, esto dará los resultados esperados. Sin embargo si cualquiera de las
clases trata de sobrescribir la clave después de que la clase padre la ha fijado
(después de llamar a súper) cualquiera de las clases hija necesitara explícitamente
fijarla y asegurarse de sobrescribir todas las clases padres. Si tienes problemas, revisa
el orden de resolución del método de una vista.

Vista para un subconjunto de objetos

Especificando model = Editor es realmente un atajo para decir: queryset =
Editor.objects.all(). Sin embargo, usando un queryset puedes filtrar una lista de
objetos y puedes especificar los objetos que quieres que se muestren en la vista.
Para escoger un ejemplo simple, puede ser que quieras ordenar una lista de libros
por fecha de publicación, con los libros más reciente al inicio:

Filtrado Dinámico

La parte crucial para hacer este trabajo está en llamar a las vistas basadas en
clases-base, ya que guardan algunas cosas útiles con self; tal como la petición
(self.request) esta incluye la posición (self.args) el nombre base (self.kwargs) los
argumentos capturados acorde a la URLconf.

Realizar trabajo extra

Nota: La URLconf aquí usa un nombre de grupo pk -- este nombre, es el nombre
predeterminado que DetailView usa para encontrar el valor de una clave primaria
que se usa para filtrar el queryset (que no es más que la clave primaria o primary
key.)
Si quieres llamar esta vista con otro nombre de grupo, puedes fijarlo a
pk_url_kwarg en la vista.
Después escribimos la vista -- get_object es un método que recupera un objeto,
simplemente sobreescribe y envuelve la llamada.

Introducción a los mixins

Los mixins son una forma de herencia múltiple, donde los comportamientos y los
atributos de múltiples clases padre, pueden heredarse y combinarse en una única
clase hija.
Los mixins son una excelente manera de reutilizar el código a través de múltiples
clases, pero vienen con un cierto costo. Cuanto más los utilizas mas se dispersa el
código, lo que dificulta leer lo que hace exactamente una clase hija y complica aún
más saber qué métodos remplazan los mixins si es que estas usando la herencia en
subclases con una cierta profundidad.

Usando un mixin en vistas genéricas

Combinando una vista ListView con un mixin SingleObjectMixin, a fin de que el
queryset para la lista paginada de libros cuelgue de un simple objeto editor. Para
hacer esto necesitamos primero obtener dos querysets diferentes:
-> Libro: queryset para usar en ListView.
Puesto que tenemos acceso a la lista de libros de un editor que queremos
listar, podemos simplemente sobrescribir el método get_queryset () y utilizar
el manejador para usar los editores del campo foráneo Libro en relación
inversa.
-> Editores: un queryset para usar con get_object().
Confiaremos en la implementación predeterminada del método get_object()
para traer el objeto correcto Editor. Sin embargo, necesitamos explícitamente
pasarle un argumento al queryset porque de otra manera la implementación
predeterminada de get_object() llamara al método get_queryset() el cual
sobrescribirá los objetos Libro devueltos en lugar de el Editor.

Mixins de Django:

-> Simple mixins
-> Single object mixins
-> Multiple object mixins
-> Editing mixins
-> Date-based mixins

Envolviendo el método as_view() con mixins

Por ejemplo, si tienes muchas vistas genéricas que necesites decorar con un
método login_required () lo podrías implementar usando un mixin como este:
from django.contrib.auth.decorators import login_required
class RequiereLogin(object):
    @classmethod
    def as_view(cls, **initkwargs):
        vista = super(RequiereLogin, cls).as_view(**initkwargs)
        return login_required(vista)

class MiVista(RequiereLogin, ...):
# Esta es la vista genérica

Manejando formularios con vistas basadas en clases genéricas

Este tecnica recorta el uso de codigo y automatiza el proceso
de respuesta a peticiones

Ejemplo de un formulario usando una clase genérica

Al trabajar con modelos podemos crear automáticamente formularios a partir de
un modelo, usando vistas genéricas basadas en clases
Esta es la forma en que las puedes utilizar:
-> Si se da el atributo de un modelo, ese modelo de clase será utilizada.
-> Si get_object () devuelve un objeto, la clase de ese objeto será utilizada.
-> Si se da un queryset, el modelo para ese queryset será utilizado.

No necesitas proveer un método success_url para una vista tipo CreateView o
UpdateView ya que usan el método get_absolute_url() de el modelo, si este está
disponible.
Si quieres usar un formulario personalizado con la clase ModelForm (como una
instancia para agregar validación) simplemente fija el valor form_class en la vista.

Nota: Observa que usamos el método reverse_lazy() en la última clase, el cual es
útil para cuando se necesita utilizar una url inversa, antes de que se cargue la
URLConf de el proyecto.

Decorando vistas de una clase-base

La forma más simple de decorar una vista basada en una clase, es decorar el
resultado de el método as_view(). El lugar más sencillo para hacer esto es en la
URLconf donde se despliega la vista. Se puede usar login_required o permission_required

Decorando una clase

Para hacer un login de autentificación en cualquier vista o clase basada en vistas genericas
crear un directorio dentro de templates con un archivo login.html donde esta el formulario de 
autentificación ejemplo templates/registratio/login.html. Con cualquiera de las formas que se use 
debe exister la url a la cual se redirecciona.

Soporte para Apis 

Supongamos que alguien quiere acceder a nuestra biblioteca de libros sobre HTTP,
usando la vista como una API. La API del cliente se conectaría de vez en cuando y
descarga la lista de libros publicados desde su última visita. Pero si no se ha
publicado ningún libro desde la última vez, sería una pérdida de CPU y de ancho de
banda obtener todos los libros de la base de datos, renderizar una respuesta
completa y enviársela al cliente. No sería preferible preguntarle a la API cuales son los
libros recientemente publicados.


Capitulo 12. Despliegue de aplicaciones

Prepara tu código base para producción

Desactiva el Modo Debug

Desactiva el Modo Debug en las plantillas

De igual forma, es necesario fijar la variable TEMPLATE_DEBUG a False en
producción. Esto para desactivar el modo depuración de las plantillas. Ya que si está
fijada en True, esta configuración le dice al sistema de plantillas de Django que
guarde información extra acerca de cada plantilla, para mostrarla en las útiles
páginas de error, si el modo DEBUG = True (esta activado).

Implementa una plantilla 404

Si DEBUG es True, Django mostrara una muy útil página de error 404. Pero si DEBUG
es False, hará algo completamente diferente: renderizara una plantilla llamada
404.html en la raíz del directorio de plantillas. Entonces, cuando estás listo para el
despliegue, necesitas crear esta plantilla y ponerle algo útil, como un mensaje de
‘‘Página no encontrada’’.
Ejemplo:
404.html
{% extends "base.html" %}
{% block title %}Página no encontrada {% endblock %}
{% block content %}
    <h1>Página no encontrada</h1>
    <p>Lo sentimos, pero la página que buscas no ha sido encontrada.</p>
{% endblock %}

Implementa una plantilla 500

De igual forma si DEBUG es False, Django no mostrara la útil página de traza de
errores, en caso de excepciones no manejadas. En su lugar mostrara y renderizara
una plantilla llamada 500.html. Tal como la página 404.html, esta plantilla debe de
localizarse en la raíz del directorio de plantillas.
Hay una ligera trampa acerca de las páginas 500.html. Nunca puedes estar seguro
por qué se renderiza esta plantilla, así que no deberías hacer nada que requiere una
conexión a la base de datos o confiar en cualquier parte potencialmente rota de tu
infraestructura. (Por ejemplo, no deberías usar etiquetas personalizadas en la
plantillas 500.) Si usas la herencia de plantillas, entonces la plantilla padre, no debería
poder conectarse a la infraestructura potencialmente rota. Por consiguiente, la mejor
forma de aprovechar esto, es evitar la herencia de plantillas y usar algo muy simple y
solo en HTML. Aquí hay un ejemplo de una página 500.html, como un punto de
partida, para que diseñes la tuya:

500.html
<!DOCTYPE html PUBLIC "//
W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
  <title>Página no disponible</title>
</head>
<body>
  <h1>Página no disponible</h1>
  <p>Lo sentimos, pero la página pedida no está disponible por que
     el servidor tiene hipo.</p>
  <p>Los desarrolladores han sido notificados, así que vuelva a revisar más
     tarde
  </p>
</body>
</html>

Establece errores de alerta

Cuando tu sitio creado con Django está corriendo y se lanza una excepción, necesitas
estar al tanto, para poder corregir cualquier defecto. Por omisión, Django está
configurado para enviar un e-mail a los desarrolladores del sitio, cuando el código
lanza una excepción; pero necesitas hacer algunas cosas para configurarlo.
-> Primero cambia la configuración ADMINS para incluir la dirección de email,
con las direcciones de cada una de las personas que necesitan ser
notificadas. Esta configuración es una tupla del tipo (nombre, email), la
tupla puede ser así:
ADMINS = (
(’John Lennon’, ’jlennon@example.com’),
(’Paul McCartney’, ’pmacca@example.com’),
)
-> Segundo, asegúrate de que tu servidor este configurado para enviar emails.
Configurar postfix, sendmail o cualquier otro servidor de e-mails,
esta fuera del alcance de este libro, pero del lado de Django, debes de
asegurarte de configurar EMAIL_HOST y establecer el ‘‘hostname’’
apropiado para tu servidor de correo. Si lo estableces a 'localhost' por
defecto, trabajara fuera de la caja en muchos entornos de servicios
compartidos. También es necesario que establezcas los parámetros de las
siguientes configuraciones: EMAIL_HOST_USER,
EMAIL_HOST_PASSWORD, EMAIL_PORT o EMAIL_USE_TLS,
dependiendo de la complejidad de tu infraestructura.
-> Por último, también establece el prefijo con EMAIL_SUBJECT_PREFIX el
cual controla el nombre que Django usa delante de los errores en los
correos electrónicos. Por defecto está establecido en '[Django]’.

Establece alertas para enlaces rotos

Si tienes la clase CommonMiddleware instalada (en tu archivo de configuración en la
variable MIDDLEWARE_CLASSES que incluye
'django.middleware.common.CommonMiddleware', lo cual ocurre por defecto)
tienes la opción de recibir un e-mail cada vez que alguien visita una página creada
con Django que lanze un error 404 con una referencia a no-vacía -- esto es cada vez
que encuentre enlaces rotos. Si quieres activar esta característica, establece
SEND_BROKEN_LINK_EMAILS a True (esta es False por defecto) y establece en la
configuración MANAGERS a la persona o personas que recibirán esos e-mails de
enlaces rotos. MANAGERS usa la misma sintaxis que ADMINS, un tupla. Por ejemplo:
MANAGERS = (
(’George Harrison’, ’gharrison@example.com’),
(’Ringo Starr’, ’ringo@example.com’),)

Como usar diferentes configuraciones para producción

Hasta ahora en este libro, hemos tratado únicamente con un simple archivo de
configuraciones settings.py generado por el comando django-admin.py startproject.
Pero como estamos listos para desplegarlo, probablemente nos encontremos con la
necesidad de usar múltiples archivos de configuraciones para mantener el entorno de
desarrollo aislado del ambiente de producción.
Por ejemplo, probablemente no quieras cambiar DEBUG de False a True cada vez
que quieras probar los cambios al código, en tu maquina de forma local. Django hace
esto muy sencillo, permitiéndote usar múltiples archivos de configuraciones.
Si quieres organizar tus archivos de configuraciones, dividiéndolos en ‘‘desarrollo’’
y ‘‘producción’’, puedes lograrlo usando una de las siguientes tres formas.
-> Establece dos archivos de configuraciones completos, de forma
independiente.
-> Establece un archivo de configuraciones ‘‘base’’ (uno para desarrollo) y un
segundo (para producción) el archivo de configuraciones simplemente
importa del primero y define lo que necesita y lo que debe sobrescribirse.
-> Usa únicamente un archivo de configuraciones y deja que Python se encargue
de la lógica y haga los cambios a las configuraciones, basado en el contexto.

Finalmente, la forma más concisa para lograr tener dos entornos de
configuraciones es usar un solo archivo, que se ramifique basado en el entorno. Una
de las formas de lograr esto es comprobar el actual ‘‘hostname.’’ Por ejemplo:
# settings.py
import socket
if socket.gethostname() == ’mylaptop’:
    DEBUG = TEMPLATE_DEBUG = True
else:
    DEBUG = TEMPLATE_DEBUG = False

DJANGO_SETTINGS_MODULE

Con todos estos cambios en el código, la siguiente parte de este capítulo se centra en
las instrucciones específicas para desplegar Django en distintos entornos, tal como
Apache, Gunicorn... Las instrucciones son diferentes para cada entorno, pero una
cosa es la misma: en cada caso necesitas decirle al servidor Web cuál es tu:
DJANGO_SETTINGS_MODULE. Este es el punto de entrada de tu aplicación Django.
DJANGO_SETTINGS_MODULE enlaza tu archivo de configuraciones, el cual
apunta a ROOT_URLCONF, que a su vez enlaza tus vistas y así sucesivamente.

El objeto application

El concepto clave para implementar usando WSGI es el llamable application que es el
modulo que el servidor de aplicaciones utiliza para comunicarse con el código
Python. Este comúnmente se provee como un objeto llamado application el cual es
un modulo Python accesible por el servidor.
El comando startproject crea un archivo llamado wsgi.py este contiene un modulo
llamable llamado application. Este es usado tanto en el servidor de desarrollo, como
en el despliegue para producción, por lo que no necesitas crearlo.
El servidor WSGI obtiene la ruta de la configuración del llamable application. El
servidor de desarrollo ‘‘runserver’’ lee la configuración de WSGI_APPLICATION, la
cual enlaza a el llamable application en el archivo wsgi.py, lo mismo pasa con un
servidor en producción.

Configura el modulo settings

Cuando el servidor WSGI carga tu aplicación, Django necesita importar el modulo de
configuraciones settings -- que es donde se define completamente la aplicación.
Django usa la variable de entorno DJANGO_SETTINGS_MODULE que contiene la
ruta para localizar apropiadamente este modulo. Puedes usar diferentes valores para
desarrollo y producción; todo depende de cómo organices tus configuraciones.
Si esta variable no está establecida, el valor por defecto es misitio.settings, donde
misitio es el nombre de tu proyecto y settings es el nombre del archivo settings.py.
Esta es la forma en que runserver carga el archivo de configuraciones por defecto.

Como desplegar con WSGI

La plataforma dominante de implementación para Django es WSGI, el estándar
Python para servidores y aplicaciones Web.
El comando administrativo startproject establece por defecto, un simple archivo
de configuración WSGI, el cual puedes personalizarse según las necesidades de tu
proyecto, y directamente adaptarse a cualquier servidor que ofrezca soporte para
WSGI, como los siguientes servidores:
-> mod_wsgi
-> apache
-> gunicorn
-> uwsgi

Usando Django con Apache y mod_wsgi
Configuración básica

Para configurar Django con mod_wsgi, primero debes asegurarte de que tienes
instalado Apache con el módulo mod_wsgi activado. Esto usualmente significa tener
una directiva LoadModule en tu archivo de configuración de Apache. Parecida a esta:
LoadModule wsgi_module /modules/mod_wsgi.so
Una vez que has instalado y activado mod_wsgi, edita el archivo httpd.conf de tu
servidor Web Apache y agrega lo siguiente. Si estas usando una versión de Apache
anterior a la 2.4, remplaza Require all granted con Allow from all y tambien agrega la
línea Order deny,allow arriba de esta.

WSGIScriptAlias / /path/to/mysite.com/mysite/wsgi.py
WSGIPythonPath /path/to/mysite.com
<Directory /path/to/mysite.com/mysite>
<Files wsgi.py>
Require all granted
</Files>
</Directory>

El primer fragmento de la línea WSGIScriptAlias es la ruta base que quieres servir
tu aplicaciones en (/ indica la raíz de la url) y la segunda es la localización de el
‘‘archivo WSGI’’ --ver más abajo en tu sistema, usualmente dentro del paquete de tu
proyecto (misitio en este ejemplo.) Esto le dice al servidor Apache ‘‘Usa mod_wsgi
para cualquier petición URL en ‘/’ o bajo ella, usando la aplicación WSGI definida en
ese archivo’’.
La línea WSGIPythonPath se asegura que el paquete del proyecto esté disponible
para importar la ruta de búsqueda de Python; en otras palabras se asegura que
import misitio trabaje.
La pieza <Directory> solo se asegura de que Apache pueda acceder al archivo
wsgi.py, ya que se utiliza para apuntar a lugares de nuestra sistema de archivos,
Lo siguiente que necesitas hacer, es asegurarte que exista una archivo wsgi.py, como
seguramente te diste cuenta el comando startproject crea este archivo por defecto al
crear el proyecto, de otra forma tendrías que crear este archivo manualmente.

Advertencia: Si varios sitios están siendo ejecutados en un simple proceso
mod_wsgi, todos ellos usarán las configuraciones de cualquiera de los procesos que
corra primero. Esto puede ser solventado con un pequeño cambio en el archivo
wsgi.py (ve los comentarios en el archivo para detalles) o puedes asegurarte de cada
sitio sea ejecutado en un proceso independiente, usando su propio demonio,
sobrescribiendo el valor por defecto usando:
os.environ["DJANGO_SETTINGS_MODULE"] = "misitio.settings" en el arhvio wsgi.py

Usando virtualenv

Si has instalado las dependencias Python de tu proyecto dentro de virtualenv,
necesitas agregar la ruta de ‘‘virtualenv’s’’ al directorio site-packages, así como el
camino de búsqueda. Para hacer esto agrega una ruta de búsqueda adicional a la
directiva WSGIPythonPath, con las múltiples rutas separadas por dos puntos (:) si
estas usando un sistema del tipo UNIX, o punto y coma (;) si estas usando Windows.
Si cualquier parte de la ruta al directorio contiene caracteres como espacios, la
cadena completa de argumentos para WSGIPythonPath debe ser citada:
WSGIPythonPath /path/to/mysite.com:/path/to/your/venv/lib/python3.X/sitepackages
Asegúrate de darle la ruta correcta a tu virtualenv, y remplazar python3.X con la
versión correcta de Python (por ejemplo python3.4).

Usando mod_wsgi en modo demonio

‘‘Modo Demonio’’ es el modo recomendado para ejecutar mod_wsgi (en plataformas
que no son Windows). Para crear el grupo de procesos requeridos por el demonio y
delegar la instancia Django para ejecutarse, necesitas agregar apropiadamente las
directivas WSGIDaemonProcess y WSGIProcessGroup. Un cambio mas es requerido
en la anterior configuración si utilizas el modo demonio no puedes usar
WSGIPythonPath, en lugar de eso debes usar la opción python-path para
WSGIDaemonProcess, por ejemplo:
WSGIDaemonProcess example.com pythonpath=/
path/to/mysite.com:/path/to/venv/lib/python3.4/sitepackages

Otra opción para servir los archivos multimedia, que no sea el mismo VirtualHost
Apache que usa Django, puedes configurar Apache para que sirva algunas URLs
estáticas y otras usando la interface mod_wsgi para Django
Este ejemplo configura Django en la raíz del sitio, pero explícitamente sirve
robots.txt, favicon.ico, y cualquier archivo CSS, y cualquier cosa en el espacio de URL
/static/ y /media/ será tratado como archivos estáticos. Todas las demás URLs será
servidas usando mod_wsgi:
Alias /robots.txt /path/to/mysite.com/static/robots.txt
Alias /robots.txt /path/to/mysite.com/static/robots.txt
Alias /favicon.ico /path/to/mysite.com/static/favicon.ico
AliasMatch ^/([^/]*\.css) /path/to/mysite.com/static/styles/$1
Alias /media/ /path/to/mysite.com/media/
Alias /static/ /path/to/mysite.com/static/
<Directory /path/to/mysite.com/static>
Require all granted
</Directory>
<Directory /path/to/mysite.com/media>
Require all granted
</Directory>
WSGIScriptAlias / /path/to/mysite.com/mysite/wsgi.py
<Directory /path/to/mysite.com/mysite>
<Files wsgi.py>
Require all granted
</Files>
</Directory>

Como servir los archivos de la interfaz administrativa

Cuando django.contrib.staticfiles está en el archivo de configuraciones en la variable
INSTALLED_APPS El entorno de desarrollo de Django sirve automáticamente los
archivos estáticos de la interfaz administrativa (y de cualquier aplicación instalada).
Este no es el caso cuando usas otro servidor para este trabajo. Tu eres responsable de
configurar Apache o cualquier otro servidor Web que utilices, para servir los archivos
de la interfaz administrativa.
Los archivos de la interfaz administrativa se localizan en
django/contrib/admin/static/admin en la distribucion de Django Es fuertemente
recomendable usar django.contrib.staticfiles para manejar los archivos de la interfaz
administrativa (Junto con el servidor Web, esto significa que puedes usar el comando
collectstatic para recolectar todos los archivos estáticos en STATIC_ROOT y luego
configurar el servidor Web para servir STATIC_ROOT, pero aquí estan otras tres
formas de hacer lo mismo:
Crea un enlace simbólico a los archivos estáticos de la interfaz administrativa
desde la raíz de Apache (esto puede requerir usar +FollowSymLinks en la
configuración de Apache)
Usa una directiva Alias, como mostramos arriba, un alias apropiado a la URL
(probablemente STATIC_URL + admin/) a la posición actual de los archivos estáticos.
Copia los archivos estáticos de la interfaz administrativa de modo que se localicen
dentro de la raíz de Apache.

Como usar Django con Gunicorn

Gunicorn (‘Unicornio verde’) es un servidor WSGI implementado en Python. No
tiene dependencias y es fácil de instalar y usar.
Hay dos formas de usar Gunicorn con Django. La primera es tratar a Gunicorn
simplemente como otra aplicación WSGI. La segunda es usar Gunicorn de forma
especial integrándolo con Django.
Una vez instalado Gunicorn, tenemos disponible un comando gunicorn que inicia
el proceso del servidor Gunicorn. Esto es tan simple, ya que gunicorn solo necesita
ser llamado con la localización del objeto aplication del WSGI.:
gunicorn [OPTIONS] MODULO
Donde MODULO es un patron del tipo NOMBRE_MODULO:NOMBRE_VARIABLE.
El nombre del modulo debe ser la ruta completa al proyecto, mientras que el nombre
de la variable se refiere al llamable WSGI el cual debe de encontrarse en el modo
especificado.
Así para un típico proyecto Django, invocar a gunicorn se vería así:
gunicorn misitio.wsgi:application
Donde misitio es el nombre del proyecto y application es el llamable del WSGI.
(Esto requiere que el proyecto este en la ruta de búsqueda de Python; la forma más
simple de hacer esto, es asegurarse de ejecutar el comando ‘‘gunicorn’’ desde el
mismo directorio en que esta el archivo manage.py)

Ajuste de Performance

No hay tal cosa como demasiada RAM

Incluso la RAM más costosa es relativamente costeable en estos días. Compra toda la
RAM que puedas, y después compra un poco más.
Los procesadores más rápidos no mejoran la performance tanto. La mayoría de los
servidores Web desperdician el 90% de su tiempo esperando I/O del disco. En
cuantos empieces a swappear, la performance directamente se muere. Los discos
más rápidos pueden ayudar levemente, pero son mucho más caros que la RAM, así
que no cuentan.
Si tienes varios servidores, el primer lugar donde poner tu RAM es en el servidor de
base de datos. Si puedes, compra suficiente ram como para tener toda tu base de
datos en memoria. Esto no es tan difícil. Hemos diseñado sitios que incluye medio
millón de artículos en menos de 2 GB de espacio.
Después, maximiza la RAM de tu servidor Web. La situación ideal es aquella en la
que ningún servidor swapea -- nunca. Si llegas a ese punto, debes poder manejar la
mayor parte del tráfico normal.

Deshabilita Keep-Alive

Keep-Alive es una característica de HTTP que permite que múltiples pedidos HTTP
sean servidos sobre una conexión TCP única, evitando la sobrecarga de conectar y
desconectar.
Esto parece bueno a primera vista, pero puede asesinar al performance de un sitio
Django. Si estás sirviendo medios desde un servidor separado, cada usuario que esté
navegando tu sitio solo requerirá una página del servidor Django cada diez segundos
aproximadamente. Esto deja a los servidores HTTP esperando el siguiente pedido
keep-alive, y un servidor HTTP ocioso consume RAM que debería estar usando un
servidor activo.

Usa memcached

A pesar de que Django admite varios back-ends de cache diferentes, ninguno de ellos
siquiera se acerca a ser tan rápido como memcached. Si tienes un sitio con tráfico
alto, ni pierdas tiempo con los otros --- usa directamente memcached.

Por supuesto, seleccionar memcached no te hace mejor si no lo usas realmente. El
capítulo te dice cómo usarlo: aprende a usar el framework de cache de Django, y
úsalo en todas las partes que te sea posible. Un uso de cache agresivo y preemptico es
usualmente lo único que se puede hacer para mantener un sitio Web funcionando
bajo el mayor tráfico.


Capitulo 13. Generacion de contenido no HTML

Django posee varias herramientas útiles que puedes usar para producir algunos 
tipos comunes de contenido no HTML: 
-> Feeds de sindicación RSS/Atom 
-> Mapas de sitios haciendo uso de Sitemaps (un formato XML originalmente 
desarrollado por Google que provee de ayuda a motores de búsqueda)

Más formalmente, una función vista debe 

-> Aceptar una instancia HttpRequest como primer argumento. 

-> Retornar una instancia HttpRequestsponse como respuesta.

Nota: Para mostrar imagenes en el Html uar, ejemplo: FileResponse(open("media/HelloWorld.jpg",'rb'))

Producción de CSV

-> El código y los comentarios deberían ser bastante claros, pero hay unas pocas 
cosas que merecen mención especial: 
-> Se le da a la respuesta el tipo MIME text/csv (en lugar del tipo predeterminado 
text/html). Esto le dice a los navegadores que el documento es un fichero CSV. 
-> La respuesta obtiene una cabecera Content-Disposition adicional, la cual 
contiene el nombre del fichero CSV. Esta cabecera (bueno, la parte ‘‘adjunta’’) 
le indicará al navegador que solicite la ubicación donde guardará el fichero 
(en lugar de simplemente mostrarlo). El nombre de fichero es arbitrario; 
llámalo como quieras. Será usado por los navegadores en el cuadro de diálogo 
‘‘Guardar como...’’ 
-> Usar el API de generación de CSV es sencillo: basta pasar response como 
primer argumento a csv.writer. La función csv.writer espera un ‘‘objeto de tipo 
fichero’’, y los objetos de tipo HttpResponse se ajustan a ello. 
-> Por cada fila en el fichero CSV, invocamos a writer.writerow, pasándole un 
objeto iterable como una lista o una tupla. 
-> El módulo CSV se encarga de poner comillas por ti, así que no tendrás que 
preocuparte por escapar caracteres en las cadenas que tengan comillas o 
comas en su interior. Limítate a pasar la información a writerow(), que hará lo 
correcto.

Generar PDF's en Django

Usar pip install reportlab para generar pdfs con python

Usamos el tipo MIME application/pdf. Esto le indica al navegador que el 
documento es un fichero PDF y no un fichero HTML. Si no incluyes esta información, 
los navegadores web probablemente interpretarán la respuesta como HTML, lo que 
resultará en jeroglíficos en la ventana del navegador. 
La respuesta obtiene una cabecera Content-Disposition adicional, la cual 
contiene el nombre del archivo PDF. Este nombre es arbitrario: llámalo como 
quieras. Solo será usado para abrir el cuadro de dialogo en el navegador ‘‘Guardar 
como...’’
En el ejemplo le agregamos attachment a la respuesta de la cabecera Content 
Disposition al nombre del archivo. Esto fuerza a los navegadores Web a presentar una 
ventana de diálogo/confirmación para manipular el documento por defecto usando 
un programa externo, sin embargo si dejamos en blanco attachment el navegador 
manipulará el PDF usando cualquier plugin que haya sido configurada para manejar 
este tipo de archivos dentro del navegador, el código es el siguiente: 
response['Content­Disposition'] = 'filename="archivo.pdf"'

Interactuar con la API ReportLab es sencillo: sólo pasa response como el primer 
argumento a canvas.Canvas. La clase Canvas espera un objeto tipo archivo, por lo 
que los objetos HttpResponse se ajustarán a la norma. 
Todos los métodos de generación de PDF subsecuentes son llamados pasándoles 
el objeto PDF (en este caso p), no response. 
Finalmente, es importante llamar a los métodos showPage() y save() del objeto 
PDF (de otra manera obtendrás un fichero PDF corrupto).

PDF's más complejos

Si estás creando un documento PDF complejo considera usar la biblioteca io como 
un lugar de almacenamiento temporal para tu fichero PDF. Esta biblioteca provee 
una interfaz para tratar con archivos tipo objetos muy eficientemente. 
En el siguiente ejemplo, obtenemos datos directamente de la base de datos, que 
creamos en los capítulos anteriores y los usamos para crear un PDF sencillo usando 
el modulo io de Python.

El Framework de Feeds de Sindicación

Nota: RSS y Atom son formatos basados en XML que se puede utilizar para 
actualizar automáticamente los ‘‘feeds’’ con el contenido de tu sitio. Lee más sobre 
RSS en à http://www.whatisrss.com/, y obtén información sobre Atom en http://www.atomenabled.org/. 
Para crear cualquier feed de sindicación, todo lo que necesitas hacer es escribir una 
pequeña clase Python. Puedes crear tantos feeds como desees.

El framework de generación de feeds de alto nivel es una vista enganchada a 
/feeds/ por convención. Django usa el final de la URL (todo lo que este después de 
/feeds/) para determinar qué feed retornar.

Debes tener en cuenta que: 
-> El feed es representado por la clase UltimosLibros el cual por convención y 
claridad residirá en un nuevo archivo llamado feeds.py, en el mismo nivel que 
models.py, aunque puede residir en cualquier parte del árbol de código. 
-> La clase Feed debe ser una subclase de django.contrib.syndication.feeds.Feed. 
-> Una vez que este configurada la URL, necesitas definir la propia clase Feed. 
Puedes pensar en una clase Feed como un tipo de clase genérica.

Una clase Feed es una simple clase Python que representa un feed de sindicación. 
Un feed puede ser simple (p. ej. ‘‘noticias del sitio’’, o una lista de las últimas entradas 
del blog) o más complejo (p. ej. mostrar todas las entradas de un blog en una 
categoría en particular, donde la categoría es variable).

Las cosas importantes a tener en cuenta son: 
-> La clase Feed es una subclase de django.contrib.syndication.views.Feed. 
-> title, link, y description corresponden a los elementos RSS estándar <title>, 
<link>, y <description> respectivamente. 
-> items() es simplemente un método que retorna una lista de objetos que 
deben incluirse en el feed como elementos <item>. Aunque este ejemplo 
retorna objetos NewsItem usando la API de base de datos de Django, no es un 
requerimiento que items() deba retornar instancias de modelos. 
-> Obtienes unos pocos bits de funcionalidad ‘‘gratis’’ usando los modelos de 
Django, pero items() puede retornar cualquier tipo de objeto que desees.

Hay solamente un paso más. En un feed RSS, cada <item> posee <title>, <link>, y 
<description>. Por lo que es necesario decirle al framework qué datos debe poner en 
cada uno de los elementos. 
-> Para especificar el contenido de <title> y <description>, Django trata de llamar 
a los metodos item_title() e item_description() en la clase Feed. Estos son 
pasados como simples parámetros item, el cual es el objeto en sí mismo. 
También estos metodos son opcionales; por defecto la representación 
Unicode del objeto es usado en ambos. 
-> Para especificar contenido con algún formato en especifico para <title> y 
 <description>, crea plantillas Django (ver capítulo 4) Puedes especificar la 
ruta con los atributos title_template y description_template en la clase Feed. 
El sistema RSS renderiza dicha plantilla por cada ítem, pasándole dos 
variables de contexto para plantillas: 

{{ obj }}: El objeto actual (uno de los tantos que retorna en items(). 
{{ site }}: Un objeto django.models.core.sites.Site representa el sitio actual. 
Esto es útil para {{ site.domain }} o {{ site.name }}.
Si no creas una plantilla para el título o la descripción, el framework utilizará 
la plantilla por omisión "{{ obj }}" --- exacto, la cadena normal de 
representación del objeto.

También puedes cambiar los nombres de estas plantillas especificando 
title_template y description_template como atributos de tu clase Feed. 
-> Para especificar el contenido de <link>, hay dos opciones. Por cada ítem en 
items(), Django primero tratará de ejecutar el método get_absolute_url() 
en dicho objeto. Si dicho método no existe, entonces trata de llamar al 
método item_link() en la clase Feed, pasándole un único parámetro, item, 
que es el objeto en sí mismo.

Un Feed más complejo

Para generar los feed's <title>, <link> y <description>, Django usa los metodos 
title(), link() y description(). En el ejemplo anterior, estos eran atributos simples de 
una clase, pero este ejemplo ilustra que estos pueden ser tanto métodos o cadenas. 
Por cada title, link y description, Django sigue el siguiente algoritmo. 
1. Primero trata de llamar al método, pasando el argumento obj, donde obj es el 
objeto retornado por get_object(). 
2. Si eso falla, trata de llamar al método sin argumentos. 
3. Si eso falla, usa los atributos de clase.

Especificar el tipo de Feed

Observa que asignas como valor de feed_type una clase, no una instancia. Los 
tipos de feeds disponibles actualmente se muestran en la siguiente tabla. 
Clase Feed                                       Formato
django.utils.feedgenerator.Rss201rev2Feed        RSS 2.01 (por defecto) 
django.utils.feedgenerator.RssUserland091Feed    RSS 0.91 
django.utils.feedgenerator.Atom1Feed             Atom 1.0

Adjuntos

Para especificar archivos adjuntos o enclosures (p. ej. recursos multimedia asociados 
al ítem del feed tales como feeds de podcasts MP3, imagenes), usa los métodos 
item_enclosure_url, item_enclosure_length, e item_enclosure_mime_type.

Esto asume, por supuesto que estamos usando el modelo Libro el cual contiene un 
campo llamado portada (que es una imagen), al cual se accede a su URL mediante 
portada.url y mediante portada.size obtenemos el tamaño en bytes.

URLs 
 
El método/atributo link puede retornar tanto una URL absoluta (p. ej. "/blog/") como 
una URL con el nombre completo de dominio y protocolo (p. ej. 
"http://www.example.com/blog/"). Si link no retorna el dominio, el framework de 
sindicación insertará el dominio del sitio actual, acorde a la variable de configuración 
SITE_ID.
Los feeds Atom requieren un <link rel="self"> que define la ubicación actual del 
feed. El framework de sindicación completa esto automáticamente, usando el 
dominio del sitio actual acorde a la variable de configuración SITE_ID.

El Framework Sitemap

Un sitemap es un fichero XML en tu sitio web que le indica a los indexadores de los 
motores de búsqueda cuan frecuentemente cambian tus páginas, así como la 
‘‘importancia’’ relativa de ciertas páginas en relación con otras (siempre hablando de 
páginas de tu sitio Web). Esta información ayuda a los motores de búsqueda a 
indexar tu sitio.

Instalación:
1. Agrega 'django.contrib.sitemaps' a tu variable de configuración 
INSTALLED_APPS. 
2. Asegúrate de que TEMPLATES tiene la opcion APP_DIRS = true
3. Asegúrate de que tienes instalado el framework sites

De forma similar a las clases Feed, los miembros de Sitemap pueden ser métodos 
o atributos. Consulta la sección ‘‘Un feed más complejo’’ para obtener más 
información sobre cómo funciona. 
Una clase Sitemap puede definir los siguientes métodos/atributos: 
-> items (requerido): Provee una lista de objetos. Al framework no le importa 
qué tipo de objeto sean; todo lo que le importa es que los objetos sean 
pasados a los métodos location(), lastmod(), changefreq(), y priority(). 
-> location (opcional): Provee la URL absoluta para el objeto dado. La ‘‘URL 
absoluta’’ significa una URL que no incluye el protocolo o el dominio. 
Estos son algunos ejemplos:
Bien: '/foo/bar/'
Mal: 'example.com/foo/bar/'
Mal: 'http://example.com/foo/bar/'
-> lastmod (opcional): La fecha de ‘‘última modificación’’ del objeto, como un 
objeto datetime de Python.
-> changefreq (opcional): Cuán a menudo el objeto cambia. Los valores posibles 
(según indican las especificaciones de Sitemaps) son: 
o 'always' 
o 'hourly' 
o 'daily' 
o 'weekly' 
o 'monthly' 
o 'yearly' 
o 'never'
-> priority (opcional): Prioridad sugerida de indexado; entre 0.0 y 1.0. La 
prioridad por omisión de una página es 0.5; ver la documentación de 
http://sitemaps.org para más información de cómo funciona priority.

FlatPageSitemap

La clase django.contrib.sitemaps.FlatPageSitemap apunta a todas las páginas planas 
definidas para el sitio actual y crea una entrada en el sitemap. Estas entradas incluyen 
solamente el atributo location --- no lastmod, changefreq, o priority.

GenericSitemap

La clase GenericSitemap (Sitemap Genérico) trabaja de forma bastante sencilla. 
Para usarla, solo crea una instancia pasándola en una variable a sitemap en forma 
de diccionario. El único requerimiento es que el diccionario tenga una entrada a un 
queryset. También debe poseer una entrada un campo "date_field" que especifica un 
campo fecha para los objetos obtenidos del queryset. Esto será usado por el atributo 
lastmod en el sitemap generado. También puedes pasar argumentos por palabras 
clave (keyword) priority y changefreq al constructor GenericSitemap para especificar 
dichos atributos para todas las URLs.

Crear un índice Sitemap

El framework sitemap también tiene la habilidad de crear índices sitemap que hagan 
referencia a ficheros sitemap individuales, uno por cada sección definida en tu 
diccionario sitemaps. 
 Las únicas diferencias de uso son: 
-> Usas dos vistas en tu URLconf: django.contrib.sitemaps.views.index y 
django.contrib.sitemaps.views.sitemap. 
->La vista django.contrib.sitemaps.views.sitemap debe tomar un parámetro que 
corresponde a una palabra clave, llamado section.

Nota: el indice funciona solo si se declara de la siguiente forma:
-> index,{'sitemaps':sitemaps},name='django.contrib.sitemaps.views.index') (name importante)
-> sitemap,{'sitemaps':sitemaps},name='django.contrib.sitemaps.views.sitemap' (name importante)

Hacer ping a Google

Puedes desear hacer un ‘‘ping’’ a Google cuando tu sitemap cambia, para hacerle 
saber que debe reindexar tu sitio Web. El framework provee una función para hacer 
justamente eso: django.contrib.sitemaps.ping_google().
El comando ping_google() únicamente trabaja si haz registrado tu sitio con Google Search Console.

ping_google() lanza la excepción django.contrib.sitemaps.SitemapNotFound si no 
puede determinar la URL de tu sitemap.

Usando el metodo save():

from django.contrib.sitemaps import ping_google
class Libro(models.Model):
    # ...
     
    def save(self, force_insert=False, force_update=False):
        super(Libro, self).save(force_insert, force_update)
        try:
            ping_google()
       except Exception:
           #Por si ocurre una excepción
            pass

Hacer ping a Google mediante manage.py

Una vez que la aplicacion sitemap es agregada a tu proyecto, puedes hacer ping a 
Google manualmente usando el comando ping_google mediante la línea de 
comandos así: 
python manage.py ping_google [/sitemap.xml]


Cap_14. Sesiones, usuarios e inscripciones

Cookies

Los desarrolladores de navegadores hace tiempo que se dieron cuenta de que esta 
carencia de estados iba a representar un problema para los desarrolladores web, y así 
fue como nacieron las cookies (literalmente galleta). Una cookie es una pequeña 
cantidad de información que el servidor delega en el navegador, de forma que este la 
almacena. Cada vez que el cliente web solicita una página del servidor, se le envía de 
vuelta la cookie.

Parametros usados en cookies

Parámetro              Default                         Descripción 
max_age                None                            El tiempo (en segundos) que la cookie debe permanecer 
                                                       activa. Si este parámetro es la cookie, desaparecerá 
                                                       automáticamente cuando se cierre el navegador. 
expires                None                            La fecha y hora en que la cookie debe expirar. Debe estar en el 
                                                       formato "Wdy, DD-Mth-YY HH:MM:SS GMT". Si se utiliza este 
                                                       parámetro, su valor tiene preferencia sobre el definido 
                                                       mediante max_age. 
path                   "/"                             La ruta o path para la cual es válida la cookie. Los navegadores 
                                                       solo reenviarán la cookie a las páginas que estén en dicha ruta. 
                                                       Esto impide que se envíe esta cookie a otras secciones de la web. 
                                                       Es especialmente útil si no se tiene el control del nivel superior 
                                                       de directorios del servidor web. 
domain                 None                            El dominio para el cual es válida la cookie. Se puede usar este 
                                                       parámetro para definir una cookie que sea apta para varios 
                                                       dominios. Por ejemplo, definiendo domain=".example.com" 
                                                       la cookie será enviada a los dominios www.example.com, 
                                                       www2.example.com y aun.otro.subdominio.example.com. 
                                                       Si a este parámetro no se le asigna ningún valor, la cookie solo 
                                                       será enviada al dominio que la definió. 
secure                False                            Si este valor se define como True, se le indica al navegador que 
                                                       sólo retorne esta cookie a las páginas que se accedan de forma 
                                                       segura (protocolo HTTPS en vez de HTTP).

Nota: Las cookies no son seguras, nunca se debe almacenar informacion esencial en ellas.
Así que tampoco debemos almacenar en las cookies datos que sean fáciles 
de falsificar. El error habitual en este escenario consiste en almacenar algo 
así como IsLoggedIn=1 en una cookie cuando el usuario se ha validado. Te 
sorprendería saber cuántos sitios web cometen este tipo de error; no lleva 
más de unos segundos engañar a sus sistemas de ‘‘seguridad’’.

El entorno de sesiones de Django

 El entorno de sesiones te permite almacenar y recuperar cualquier dato que 
quieras basándote en la sesión del usuario. Almacena la información relevante solo 
en el servidor y abstrae todo el problema del envío y recepción de las cookies. Estas 
solo almacenan una versión codificada (hash) del identificador de la sesión, y ningún 
otro dato, lo cual te aísla de la mayoría de los problemas asociados con las cookies.

Como activar las sesiones 
 
Las sesiones se implementan mediante un poco de middleware y un modelo Django. 
Para activar las sesiones, necesitas seguir los siguientes pasos: 
1. Editar el valor de MIDDLEWARE_CLASSES de forma que contenga 
'django.contrib.sessions.middleware.SessionMiddleware'. 
2. Comprueba que 'django.contrib.sessions' esté incluido en el valor de 
INSTALLED_APPS (y ejecuta el comando python manage.py migrate)

Usando las sesiones en las vistas

# Asigna un valor a la sesión:
request.session["fav_color"] = "blue"
# Trae el valor de la sesión – puede ser llamado en diferentes vistas o e muchas
# peticiones  t(o en  ambas):
fav_color = request.session["fav_color"] # Limpia el item para la sesion:
del request.session["fav_color"] # Verifica que la sesión contenga una clave:
if "fav_color" in request.session:

Hay dos o tres reglas muy sencillas para usar eficazmente las sesiones en Django: 

-> Debes usar sólo cadenas de texto normales como valores de clave en 
request.session, en vez de, por ejemplo, enteros, objetos, etc. Esto es más 
un convenio que un regla en el sentido estricto, pero merece la pena 
seguirla.
-> Los valores de las claves de una sesión que empiecen con el carácter 
subrayado están reservados para uso interno de Django. En la práctica, sólo 
hay unas pocas variables así, pero, a no ser que sepas lo que estás haciendo 
(y estés dispuesto a mantenerte al día en los cambios internos de Django), 
lo mejor que puedes hacer es evitar usar el carácter subrayado como prefijo 
en tus propias variables; eso impedirá que Django pueda interferir con tu 
aplicación.
-> Nunca reemplaces request.session por otro objeto, y nunca accedas o 
modifiques sus atributos. Utilízalo sólo como si fuera un diccionario.

Comprobar las configuraciones de las cookies

Como ya mencionamos, no se puede confiar en que cualquier navegador sea capaz 
de aceptar cookies. Por ello, Django incluye una forma fácil de comprobar que el 
cliente del usuario disponga de esta capacidad. Sólo es necesario llamar a la función 
request.session.set_test_cookie() en una vista, y comprobar posteriormente, en otra 
vista distinta, el resultado de llamar a request.session.test_cookie_worked(). 
Esta división un tanto extraña entre las llamadas a set_test_cookie() y 
test_cookie_worked() se debe a la forma es que trabajan las cookies. Cuando se define 
una cookie, no tienes forma de saber si el navegador la ha aceptado realmente hasta 
la siguiente solicitud. 
Es una práctica recomendable llamar a la función delete_test_cookie() para limpiar 
la cookie de prueba después de haberla usado. Lo mejor es hacerlo justo después de 
haber verificado que las cookies funcionan.

Usar sesiones fuera de las vistas

Internamente, cada sesión es simplemente un modelo de entidad de Django como 
cualquier otro, definido en django.contrib.sessions.models. Cada sesión se identifica 
gracias a un hash pseudo-aleatorio de 32 caracteres, que es el valor que se almacena
en la cookie. Dado que es un modelo normal, puedes acceder a las propiedades de las 
sesiones usando la API de acceso a la base de datos de Django

Cuándo se guardan las sesiones

Se puede cambiar este comportamiento, especificando la opción 
SESSION_SAVE_EVERY_REQUEST a True. Si lo hacemos así, Django almacenará la 
sesión en la base de datos en cada petición, incluso si no se ha modificado ninguno 
de sus valores. 
Fíjate que la cookie de sesión sólo se envía cuando se ha creado o modificado una 
sesión. Si SESSION_SAVE_EVERY_REQUEST está como True, la cookie de sesión será 
reenviada en cada petición. De forma similar, la sección de expiración (‘’expires’‘) se 
actualizará cada vez que se reenvíe la cookie.

Sesiones breves frente a sesiones persistentes

El valor por omisión de la opción SESSION_EXPIRE_AT_BROWSER_CLOSE es 
False, lo que significa que las cookies serán almacenadas en el navegador del usuario 
durante SESSION_COOKIE_AGE segundos (cuyo valor por defecto es de dos 
semanas, o 1.209.600 segundos). Estos valores son adecuados si no quieres obligar a 
tus usuarios a validarse cada vez que abran el navegador y accedan a tu página. 
Si SESSION_EXPIRE_AT_BROWSER_CLOSE se establece a True, Django usará 
cookies que se invalidarán cuando el usuario cierre el navegador.

Opción                    Descripción                                               Default 
SESSION_COOKIE_DOMAIN     El Dominio a utilizar por la cookie de                    None 
                          sesión. Se puede utilizar, por ejemplo, el 
                          valor ".lawrence.com" para utilizar la 
                          cookie en diferentes subdominios. El 
                          valor None indica una cookie estándar. 

SESSION_COOKIE_NAME       El nombre de la cookie de sesiones.                      "sessionid"
                          Puede ser cualquier cadena de texto. 
                          
SESSION_COOKIE_SECURE     Indica si se debe usar una cookie segura                 False
                          para la cookie de sesión. Si el valor es 
                          True, la cookie se marcará como segura, 
                          lo que significa que sólo se podrá utilizar 
                          mediante el protocolo HTTPS. 

DETALLES TÉCNICOS 
Para los más curiosos, he aquí una serie de notas técnicas acerca de algunos aspectos 
interesantes de la gestión interna de las sesiones: 
El diccionario de la sesión acepta cualquier objeto Python capaz de ser serializado 
con pickle. Véase la documentación del módulo pickle incluido en la biblioteca 
estándar de Python para más información. 
Los datos de la sesión se almacenan en una tabla en la base de datos llamada 
django_session. 
Los datos de la sesión son suministrados bajo demanda. Si nunca accedes al 
atributo request.session, Django nunca accederá a la base de datos.
Django sólo envía la cookie si tiene que hacerlo. Si no modificas ningún valor de la 
sesión, no reenvía la cookie (a no ser que hayas definido 
SESSION_SAVE_EVERY_REQUEST como True). 
El entorno de sesiones de Django se basa entera y exclusivamente en las cookies. 
No almacena la información de la sesión en las URL, como recurso extremo en el 
caso de que no se puedan utilizar las cookies, como hacen otros entornos (PHP, JSP). 
Esta es una decisión tomada de forma consciente. Poner los identificadores de 
sesión en las URL no solo hace que las direcciones sean más feas, también hace que 
el sistema sea vulnerable ante un tipo de ataque en que se roba el identificador de la 
sesión utilizando la cabecera Referer.

Usuarios e identificación

El sistema también es llamado sistema aut/aut (autenticaficación y 
autorización). El nombre implica que, a menudo, tratar con los usuarios implica dos 
procesos. Se necesita: 
• Verificar (autentificación) que un usuario es quien dice ser (Normalmente 
comprobando un nombre de usuario y una contraseña contra una tabla de 
una base de datos) 
• Verificar que el usuario está autorizado (autorización) a realizar una 
operación determinada (normalmente comprobando una tabla de permisos)

Siguiendo estos requerimientos, el sistema aut/aut de Django consta de los 
siguientes componentes: 
 
1. Usuarios: Personas registradas en tu sitio web 
2. Permisos: Valores binarios (Si/No) que indican si un usuario puede o no 
realizar una tarea determinada. 
3. grupos: Una forma genérica de aplicar etiquetas y permisos a más de un 
usuario. 
4. mensajes: Un mecanismo sencillo que permite enviar y mostrar mensajes del 
sistema usando una cola.
5. Perfiles: Un mecanismo que permite extender los objetos de tipo usuario con 
campos adicionales.

Habilitar el soporte para autentificación

De igual manera, viene instalado por defecto, por lo que solo es necesario seguir los siguientes 
pasos si previamente la has desinstalado: 
• Comprueba que el sistema de sesiones esté activo, tal y como se explico 
previamente en este capítulo. Seguir la pista de los usuarios implica usar 
cookies, y por lo tanto necesitamos el entorno de sesiones operativo. 
• Incluye 'django.contrib.auth' dentro de tu INSTALLED_APPS y ejecuta los 
comandos makemigration y migrate. 
• Asegúrate de que 
'django.contrib.auth.middleware.AuthenticationMiddleware' está incluido en 
MIDDLEWARE_CLASSES después de SessionMiddleware.

Una vez resuelto este tema, ya estamos preparados para empezar a lidiar con los 
usuarios en nuestras vistas. La principal interfaz que usarás para trabajar con los 
datos del usuario dentro de una vista es request.user; es un objeto que representa al 
usuario que está conectado en ese momento. Si no hay ningún usuario conectado, 
este objeto será una instancia de la clase AnonymousUser.
Puedes saber fácilmente si el usuario está identificado o no con el método 
is_authenticated()

Utilizando usuarios

Las tablas 14-3 y 14-4 listan todos los 
campos y métodos, respectivamente, de los objetos de la clase User.

Campo                                           Descripción 
username                                        Obligatorio; 30 caracteres como máximo. Sólo acepta caracteres 
                                                alfanuméricos (letras, dígitos y el carácter subrayado). 
first_name                                      Opcional; 30 caracteres como máxim
last_name                                       Opcional; 30 caracteres como máximo. 
email                                           Opcional. Dirección de correo electrónico. 
password                                        Obligatorio. Un código de comprobación (hash), junto con otros 
                                                metadatos de la contraseña. Django nunca almacena la contraseña en 
                                                crudo. Véase la sección ‘‘Cambia contraseñas’’ para más información 
is_staff                                        Booleano. Indica que el usuario puede acceder a las secciones de administración. 
is_active                                       Booleano. Indica que la cuenta puede ser usada para identificarse. Se 
                                                puede poner a False para deshabilitar a un usuario sin tener que borrarlo de la tabla. 
is_superuser                                    Booleano. Señala que el usuario tiene todos los permisos, aún cuando 
                                                no se le hayan asignado explícitamente 
last_login                                      Fecha y hora de la última vez que el usuario se identificó. Se asigna 
                                                automáticamente a la fecha actual por defecto. 
date_joined                                     Fecha y hora en que fue creada esta cuenta de usuario. Se asigna 
                                                automáticamente a la fecha actual en su momento.


Método                                          Descripción 
is_authenticated()                              Siempre devuelve True para usuario reales. Es una 
                                                forma de determinar si el usuario se ha identificado. 
                                                esto no implica que posea ningún permiso, y 
                                                tampoco comprueba que la cuenta esté activa. Sólo 
                                                indica que el usuario se ha identificado con éxito. 
is_anonymous()                                  Devuelve True sólo para usuarios anónimos, y False 
                                                para usuarios ‘‘reales’’. En general, es preferible usar 
                                                el método is_authenticated(). 
get_full_name()                                 Devuelve la concatenación de los campos 
                                                first_name y last_name, con un espacio en medio. 
set_password(passwd)                            Cambia la contraseña del usuario a la cadena de 
                                                texto en claro indicada, realizando internamente las 
                                                operaciones necesarias para calcular el código de 
                                                comprobación o hash necesario. Este método no
                                                guarda el objeto User. 
check_password(passwd)                          devuelve True si la cadena de texto en claro que se 
                                                le pasa coincide con la contraseña del usuario. 
                                                Realiza internamente las operaciones necesarias
                                                para calcular los códigos de comprobación o hash
                                                necesarios.
get_group_permissions()                         Devuelve una lista con los permisos que tiene un 
                                                usuario, obtenidos a través del grupo o grupos a las 
                                                que pertenezca. 
get_all_permissions()                           Devuelve una lista con los permisos que tiene 
                                                concedidos un usuario, ya sea a través de los grupos 
                                                a los que pertenece o bien asignados directamente. 
has_perm(perm)                                  Devuelve True si el usuario tiene el permiso 
                                                indicado. El valor de perm está en el formato 
                                                `"package.codename". Si el usuario no está activo, 
                                                siempre devolverá False. 
has_perms(perm_list)                            Devuelve True si el usuario tiene todos los permisos 
                                                indicados. Si el usuario no está activo, siempre 
                                                devolverá False. 
has_module_perms(app_label)                     Devuelve True si el usuario tiene algún permiso en 
                                                la etiqueta de aplicación indicada, app_label. Si el 
                                                usuario no está activo, siempre devolverá False. 
get_and_delete_messages()                       Devuelve una lista de mensajes (objetos de la clase 
                                                Message) de la cola del usuario, y los borra 
                                                posteriormente. 
email_user(subj, msg)                           Envía un correo electrónico al usuario. El mensaje 
                                                aparece como enviado desde la dirección indicada 
                                                en el valor DEFAULT_FROM_EMAIL. Se le puede 
                                                pasar un tercer parámetro opcional, from_email, 
                                                para indicar otra dirección de remite distinta.


Iniciar y cerrar sesión

Django proporciona vistas predefinidas para gestionar la entrada del usuario, (el 
momento en que se identifica), y la salida, (es decir, cuando cierra la sesión), además 
de otros trucos ingeniosos. Pero antes de entrar en detalles, veremos cómo hacer que 
el usuario puedan iniciar y cerrar la sesión ‘‘a mano’’. Django incluye dos funciones 
para realizar estas acciones, en el módulo django.contrib.auth: authenticate() y 
login().
Para autentificar un identificador de usuario y una contraseña, se utiliza la función 
authenticate(). esta función acepta dos parámetros , username y password, y 
devuelve un objeto de tipo User si la contraseña es correcta para el identificador de 
usuario. Si falla la comprobación (ya sea porque sea incorrecta la contraseña o 
porque sea incorrecta la identificación del usuario), la función devolverá None

 Si el usuario se identifica correctamente, su navegador será redirigido a 
/accounts/profile/.Puedes indicar una dirección distinta especificando un tercer 
campo (normalmente oculto) que se llame next, cuyo valor debe ser la URL a 
redireccionar después de la identificación. También puedes pasar este valor como un 
parámetro GET a la vista de identificación y se añadirá automáticamente su valor al 
contexto en una variable llamada next, que puedes incluir ahora en un campo oculto.

Limitar el acceso a los usuarios identificados

Esto es lo que hace el decorador: " login_required" 
• Si el usuario no está identificado, redirige a la dirección /accounts/login/, 
incluyendo la url actual como un parámetro con el nombre next, por ejemplo 
/accounts/login/?next=/polls/3/. 
• Si el usuario está identificado, ejecuta la vista sin ningún cambio. La vista 
puede asumir sin problemas que el usuario está identificado correctamente.

Limitar el acceso a usuarios que pasan una prueba

De nuevo, Django proporciona una forma abreviada llamada user_passes_test().
Requiere que se la pasen unos argumentos y genera un decorador especializado para 
cada situación en particular: 
def puede_votar(user):
    return user.is_authenticated() and user.has_perm("biblioteca.puede_votar")
@user_passes_test(puede_votar, login_url="/login/")
def votar(request):
    if request.user.is_authenticated() and request.user.has_perm('biblioteca.votar')):
        # Votar aqui:
    else:
        return HttpResponse("Puedes  votar.")
 El decorador user_passes_test tiene un parámetro obligatorio: un objeto que se 
pueda llamar (normalmente una función) y que a su vez acepte como parámetro un 
objeto del tipo User, y devuelva True si el usuario puede acceder y False en caso 
contrario.
En este ejemplo, hemos usado también un segundo parámetro opcional, login_url, 
que te permite indicar la url de la página que el usuario debe utilizar para 
identificarse (/accounts/login/ por defecto).

Comprobar si un usuario posee un determinado permiso es una tarea muy 
frecuente, así que Django proporciona una forma abreviada para estos casos: El 
decorador permission_required(). Usando este decorador, el ejemplo anterior se 
podría codificar así:
from django.contrib.auth.decorators import permission_required
@permission_required('biblioteca.puede_votar', login_url="/login/")
def votar(request):
    ...

Usar información de autentificación en plantillas

Cuando se usa RequestContext, el usuario actual (ya sea una instancia de User o 
de AnonymousUser) es accesible en la plantilla con el nombre {{ user }}: 
{% if user.is_authenticated %}
  <p>Bienvenido, {{ user.username }}. Gracias por identificarte.</p>
{% else %}
  <p>Bienvenido, nuevo usuario. Por favor identifícate.</p>
{% endif %}

Hay dos formas de usar este objeto perms. Puedes usar {{ perms.polls }} para 
comprobar si un usuario tienen algún permiso para una determinada aplicación, o se 
puede usar una forma más específica, como {{ perms.polls.can_vote }}, para 
comprobar si el usuario tiene concedido un permiso en concreto.

El resto de detalles: permisos, grupos, mensajes

Permisos

El sistema de administración de Django utiliza los siguientes permisos:
-> Acceso a visualizar el formulario ‘‘Añadir’’, y Añadir objetos, está limitado a los 
usuarios que tengan el permiso add para ese tipo de objeto. 
-> El acceso a la lista de cambios, ver el formulario de cambios y cambiar un 
objeto está limitado a los usuarios que tengan el permisos change para ese 
tipo de objeto. 
-> Borrar objetos está limitado a los usuarios que tengan el permiso delete para 
ese tipo de objeto.

Igual que con los usuarios, los permisos se implementa en un modelo Django que 
reside en el módulo django.contrib.auth.models. Esto significa que puedes usar la 
API de acceso a la base de datos para interactuar con los permisos de la forma que 
quieras

Grupos

Al igual que con los usuarios, la manera más sencilla de gestionar los grupos es 
usando la interfaz de administración de Django. Los grupos, en cualquier caso, son 
modelos Django que residen en el módulo django.contrib.auth.models así que, al 
igual que en el caso anterior, puedes usar la API de acceso a la base de datos para 
trabajar con los grupos a bajo nivel.

Mensajes

Puedes usar la misma API para enviar o mostrar mensajes en tu propia aplicación. 
Las llamadas de la API son bastante simples: 
 Para crear un nuevo mensaje usa 
user.message_set.create(message='message_text').


El sistema de cache

Memcached

Nota: Necesita ser instalado (en sistemas Linux)

En el siguiente ejemplo, Memcached está corriendo en localhost (127.0.0.1) en el 
puerto 11211, usando como dependencia python-memcached:
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
        'LOCATION': '127.0.0.1:11211',
    } }
En el siguiente ejemplo, Memcache está disponible a través del socket local unix, 
que usa el archivo /tmp/memcached.sock como socket, usando los enlaces 
proporcionados por python-memcached:
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
        'LOCATION': 'unix:/tmp/memcached.sock',
    } }

Cache en Base de datos

Primero, crea la tabla de cache corriendo el siguiente comando: 
python manage.py createcachetable [nombre_tabla_cache]

Una vez que se hayas creado la tabla, usa la propiedad LOCATION como 
LOCATION:nombre_tabla, donde nombre_tabla es el nombre de la tabla en la base 
de datos y usa como BACKEND django.core.cache.backends.db.DatabaseCache 
En el siguiente ejemplo, el nombre de la tabla para el cache es mi_tabla_cache:
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
        'LOCATION': 'mi_tabla_cache',
    } }

Cache en Sistema de Archivos

Por ejemplo, para almacenar los datos de la cache en /var/tmp/django_cache, 
coloca lo siguiente:
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': '/var/tmp/django_cache',
    } }
Si usas Windows, especifica la letra de la unidad al comienzo de la ruta de 
directorios de esta forma:
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': 'c:/usuarios/temp',
    } }

Cache en Memoria local

Para usarla, usa como BACKEND a django.core.cache.backends.locmem.LocMemCache. Por ejemplo:
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'LOCATION': 'unico­proceso'
    } }

El atributo LOCATION de la cache es usada para identificar de forma individual el 
almacenamiento de la memoria. Si utilizas únicamente un proceso puedes omitir 
LOCATION; sin embargo si utilizas más de uno, necesitas asignar un nombre a al 
menos uno de los procesos para mantenerlos separados. 
Observa que cada proceso tendrá su propia instancia de cache privada, lo cual 
significa que no es posible el proceso cruzado de cache. Esto obviamente también 
significa que la memoria local de cache no es particularmente muy eficiente, así que 
no es una buena opción para usar en ambientes de producción. Es recomendable 
solo para desarrollo.

Cache personalizada

Para usar almacenamiento externo de cache con Django, usa la ruta de 
importaciones de Python como BACKEND y carga la configuración de la cache así:
CACHES = {
    'default': {
        'BACKEND': 'ruta.a.backend',
    } }
Puedes encontrar el código fuente en el directorio ubicado en: 
django/core/cache/backends/

Cache tonta (para desarrollo)

Esta es útil cuando tienes un sitio en producción que usa mucho cache en varias 
partes y en un entorno de desarrollo/prueba en el cual no quieres hacer cache. En ese 
caso, usa BACKEND como django.core.cache.backends.dummy.DummyCache en el 
archivo de configuración para tu entorno de desarrollo, por ejemplo:
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.dummy.DummyCache',
    } }

Argumentos de cache

• TIMEOUT: El tiempo de vida por omisión, en segundos, que usará la cache. 
Este argumento tomará el valor de 300 segundos (5 minutos) si no se lo 
especifica. 
También puedes especificar TIMEOUT como None, por defecto la clave de la 
cache nunca expira. 
• OPTIONS: Cualquier opción que se necesite pasar a la cache. La lista de 
opciones validas dependerá de cada backend, por lo que el almacenamiento 
de cache proporcionado por librerías de terceros, será pasado con sus 
opciones directamente bajo la cache de la librería. 
Los almacenamientos de cache que implementan sus propias estrategias de 
selección (por ejemplo: en memoria, archivos y en base de datos) respetan las 
siguientes opciones: 
• MAX_ENTRIES: Para la cache de memoria local, y la cache de base de datos, 
es el número máximo de entradas permitidas en la cache a partir del cual los 
valores más viejos serán eliminados. Tomará un valor de 300 si no se lo 
especifica. 
• CULL_FREQUENCY: La proporción de entradas que serán sacrificadas 
cuando la cantidad de MAX_ENTRIES es alcanzada. La proporción real es 
1/CULL_FREQUENCY, si quieres sacrificar la mitad de las entradas cuando se 
llegue a una cantidad de MAX_ENTRIES coloca CULL_FREQUENCY=2. Este 
argumento tomará un valor de 3 si no se especifica. Un valor de 0 para CULL_FREQUENCY 
significa que toda la cache será limpiada cuando se llegue a una cantidad de entradas 
igual a MAX_ENTRIES. Esto hace que el proceso de limpieza de la cache sea mucho más rápido, con 
el costo de perder más datos de la cache. Este argumento tomará un valor de 3 
si no se especifica.
• KEY_PREFIX: Una cadena que automáticamente incluye (agrega por default) 
todas las claves de caches usadas por el servidor Django. 
• VERSION El número de versión de las claves de cache generadas por el 
servidor Django. 
• KEY_FUNCTION: Una cadena que contiene la ruta (usando el punto) a la 
función que define la forma en que está compuesta el prefijo, la versión y la 
clave, en la clave de la cache final.

La cache por sitio

Una vez que hayas especificado CACHE, la manera más simple de usar la cache es 
colocar en cache el sitio entero. Esto significa que cada página que no tenga 
parámetros GET o POST será puesta en cache por un cierto período de tiempo la 
primera vez que sean pedidas.

MIDDLEWARE_CLASSES = (
    'django.middleware.cache.UpdateCacheMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.cache.FetchFromCacheMiddleware', )


Luego, agrega las siguientes propiedades en el archivo de configuración de 
Django: 
• CACHE_MIDDLEWARE_ALIAS: El nombre del alias para usar como 
almacenaje. 
• CACHE_MIDDLEWARE_SECONDS: El tiempo en segundos que cada página 
será mantenida en la cache. 
• CACHE_MIDDLEWARE_KEY_PREFIX: Si la cache es compartida a través de 
múltiples sitios usando la misma instalación Django, coloca esta propiedad 
como el nombre del sitio, u otra cadena que sea única para la instancia de 
Django, para prevenir colisiones. Usa una cadena vacía si no te interesa.

Cache para vistas

Una forma más granular de usar el framework de cache es colocar en cache la salida 
de las diferentes vistas. Esto tiene el mismo efecto que la cache por sitio (incluyendo 
la omisión de colocar en cache los pedidos con parámetros GET y POST). Se aplica a 
cualquier vista que tú especifiques, en vez de aplicarse al sitio entero.

from django.views.decorators.cache import cache_page
@cache_page(60 * 15)
def mi_vista(request, param):
    ...

(Toma nota de que lo hemos escrito como 60 * 15 para que sea entendible. 60 * 15 
será evaluado como 900 ---que es igual a 15 minutos multiplicados por 60 segundos 
cada minuto.)

Los pedidos a /foo/1/ y a /foo/23/ serán puestos en cache separadamente, como 
es de esperar. Pero una vez que una misma URL es pedida (p.e. /foo/23/), los 
siguientes pedidos a esa URL utilizarán la cache. 
cache_page toma un argumento de clave opcional: llamado cache, el cual puede 
usarse directamente en el decorador especificando la cache (tomada de el archivo de 
configuración de la variable CACHE) para cachear la vista. Por defecto, el cache para 
usar será especificado con cualquier cache que queramos, por ejemplo: 
@cache_page(60 * 15, cache="cache_especial")
def mi_vista(request):
    ...
    algun_metodo()

Cache por vista en la URLconf

Los ejemplos en la sección anterior incrustan la cache en las vistas, porque el 
decorador cache_page modifica la función mi_vista en la misma vista. Este enfoque 
acopla tu vista con el sistema de cache, lo cual no es lo ideal por varias razones. Por 
ejemplo, puede que quieras rehusar las funciones de la vista en otro sitio sin cache, o 
puede que quieras distribuir las vistas a gente que quiera usarlas sin que sean 
colocadas en la cache. La solución para estos problemas es especificar la cache por 
vista en URLconf en vez de especificarla junto a las vistas mismas.

from django.views.decorators.cache import cache_page
urlpatterns = [
    url(r'^foo/([0­9]{1,2})/$', cache_page(60 * 15)(mi_vista)),
]


La API de cache de bajo nivel

Quizás, por ejemplo, tu sitio incluye una vista cuyos resultados dependen de 
diversas consultas costosas, lo resultados de las cuales cambian en intervalos 
diferentes. En este caso, no sería ideal usar la página entera en cache que la cache por 
sitio o por vista ofrecen, porque no querrás guardar en cache todo el resultado (ya 
que los resultados cambian frecuentemente), pero querrás guardar en cache los 
resultados que rara vez cambian.
>>> from django.core.cache import cache
 La interfaz básica es set(key, value, timeout) y get(key): 
>>> cache.set('mi_clave', '¡Hola Mundo!', 30)
>>> cache.get('mi_clave') ' ¡Hola Mundo!'

El argumento timeout es opcional y obtiene el valor del argumento timeout de la 
variable CACHE, explicado anteriormente, si no se lo especifica. 
Si el objeto no existe en la cache, o el sistema de cache no se puede alcanzar, 
cache.get() devuelve None

Para obtener múltiples valores de la cache de una sola vez, usa cache.get_many(). 
Si al sistema de cache le es posible, get_many() tocará la cache sólo una vez, al 
contrario de tocar la cache por cada valor. get_many() devuelve un diccionario con 
todas las claves que has pedido que existen en la cache y todavía no han expirado:
>>> cache.set('a', 1)
>>> cache.set('b', 2)
>>> cache.set('c', 3)
>>> cache.get_many(['a', 'b', 'c'])

Finalmente, puedes eliminar claves explícitamente con cache.delete(). Esta es una 
manera fácil de limpiar la cache para un objeto en particular: 
>>> cache.delete('a')

Caches downstream

Este capítulo se ha enfocado en la cache de tus propios datos. Pero existe otro tipo de 
cache que es muy importante para los desarrolladores web: la cache realizada por los 
downstream. Estos son sistemas que colocan en cache páginas aún antes de que estas 
sean pedidas a tu sitio Web.

Usar el encabezado Vary

El encabezado Vary define cuales encabezados debería tener en cuenta un sistema de 
cache cuando construye claves de su cache. Por ejemplo, si el contenido de una 
página Web depende de las preferencias de lenguaje del usuario, se dice que la 
página ‘‘varía según el lenguaje’’.

Para hacer esto en Django, usa el decorador vary_on_headers como sigue: 
from django.views.decorators.vary import vary_on_headers
@vary_on_headers('User­Agent')
def mi_vista(request):
    # ...
@vary_on_headers('User­Agent', 'Cookie')
def mi_vista(request):
    # ...
Como las variaciones con las cookies son tan comunes existe un decorador 
vary_on_cookie.
@vary_on_cookie
def mi_vista(request):
    # ...

También puedes usar django.utils.cache.patch_vary_headers como función de 
ayuda. Esta función fija o añade al Vary header, por ejemplo:
from django.utils.cache import patch_vary_headers
def mi_vista(request):
    # ...
    response = render_to_response('template_name', context)
    patch_vary_headers(response, ['Cookie'])
    return response


Controlando el cache: usando otros Encabezados

Por lo que las aplicaciones Web necesitan una manera de indicarle a la cache cuales datos son privados y cuales 
son públicos.
La solución es indicar que la copia en cache de una página es ‘‘privada’’. Para 
hacer esto en Django usa el decorador de vista cache_control: 
from django.views.decorators.cache import cache_control
@cache_control(private=True)
def mi_vista(request):
     # ...

Django, utiliza el decorador cache_control para especificar estos parámetros de la 
cache. En el siguiente ejemplo, cache_control le indica a la cache revalidarse en cada 
acceso y almacenar versiones en cache hasta por 3.600 segundos: 
from django.views.decorators.cache import cache_control
@cache_control(must_revalidate=True, max_age=3600)
def mi_vista(request):
    ...
    
 Cualquier directiva Cache-Control de HTTP válida es válida en cache_control(). 
Aquí hay una lista completa: 
-> public=True
-> private=True
-> no_cache=True
-> no_transform=True
-> must_revalidate=True
-> proxy_revalidate=True
-> max_age=num_seconds
-> s_maxage=num_seconds

Otras optimizaciones 
 
Django incluye otras piezas de middleware que pueden ser de ayuda para optimizar 
el rendimiento de tus aplicaciones: 
-> django.middleware.http.ConditionalGetMiddleware agrega soporte para 
navegadores modernos para condicionar respuestas GET basadas en los 
encabezados ETag y Las-Modified. 
-> django.middleware.gzip.GZipMiddleware comprime las respuestas para todos 
los navegadores modernos, ahorrando ancho de banda y tiempo de 
transferencia.

Orden de MIDDLEWARE_CLASSES 
 
Si utilizas CacheMiddleware, es importante colocarlas en el lugar correcto dentro de 
la propiedad MIDDLEWARE_CLASSES, porque el middleware de cache necesita 
conocer los encabezados por los cuales cambiar el almacenamiento en la cache. 
Coloca el CacheMiddleware después de cualquier middleware que pueda agregar 
algo al encabezado Vary, incluyendo los siguientes: 
• SessionMiddleware, que agrega Cookie 
• GZipMiddleware, que agrega Accept-Encoding 
• LocaleMiddleware que agrega Accept-Language


Cap_16. El paquete django.contrib

django.contrib consiste de los siguientes paquetes: 
• admin: el sitio automático de administración. Consulta el capítulo 6. 
• admindocs: La auto documentación para el sitio administrativo. 
• auth: el framework de autenticación de Django. Consulta el capítulo 14. 
• contenttypes: un framework para conectar ‘‘tipos’’ de contenido, en que cada 
modelo de Django instalado es un tipo de contenido aislado. Este framework 
es usado internamente por otras aplicaciones ‘‘contrib’’, y está especialmente 
enfocada a los desarrolladores de Django muy avanzados. Dichos 
desarrolladores pueden hallar más información sobre esta aplicación, leyendo 
el código fuente que está en django/contrib/contenttypes/.
• csrf: protección ante un ataque de falsificación de petición en sitios cruzados, 
en inglés Cross-Site Request Forgery (CSRF). Consulta la sección titulada 
‘‘Protección contra CSRF’’ más adelante. 
• flatpages: un framework para administrar contenido HTML simple, ‘‘plano’’, 
dentro de la base de datos. Consulta la sección titulada ‘‘Flatpages’’ más 
adelante. 
• humanize: un conjunto de filtros de plantillas Django, útiles para darle un 
‘‘toque de humanidad’’ a los datos. Consulta la sección titulada 
‘‘Humanizando datos’’ más adelante. 
• gis: Extencion para Django que provee soporte para GIS (Sistema de 
Información Geográfica). Permite a los modelos de Django, por ejemplo 
almacenar datos geográficos y optimizar consultas geográficas. Esta es una 
larga y compleja librería, consulta mas detalles en: à http://geodjango.org/ 
• redirects: un framework para administrar redirecciones. Consulta la sección 
titulada ‘‘Redirects’’ más adelante.
• sessions: el framework de sesiones de Django. Consulta el capítulo 12. 
• sitemaps: un framework para generara archivos de mapas de sitio XML. 
Consulta él capítulo 13. 
• sites: un framework que te permite operar múltiples sitios web desde la 
misma base de datos, y con una única instalación de Django. 
• syndication: un framework para generar documentos de sindicación (feeds), 
en RSS y en Atom. Consulta él capítulo 13. 
• webdesign: Agregados en Django, particularmente útiles en el diseño Web 
más que en el desarrollo. Este incluye únicamente una etiqueta {% lorem %}. 
que permite escribir texto en las plantillas.

Sites

Como usar el framework sites

Sites más que un framework, es una serie de convenciones. Toda la cosa se basa en 
dos conceptos simples: 
• El modelo Site, que se halla en django.contrib.sites, tiene los campos domain 
y name. 
• La opción de configuración SITE_ID especifica el ID de la base de datos del 
objeto Site asociado con este archivo de configuración en particular.

La manera en que uses estos dos conceptos queda a tu criterio, pero Django los 
usa de varios modos de manera automática, siguiendo convenciones simples. 
 Para instalar la aplicación sites, sigue estos pasos: 
1. Agrega 'django.contrib.sites' a tu INSTALLED_APPS. 
2. Ejecuta el comando python manage.py migrate para instalar la tabla 
django_site en tu base de datos. 
3. Agrega uno o más objetos Site, por medio del sitio de administración de 
Django, o por medio de la API de Python. Crea un objeto Site para cada 
sitio/dominio que esté respaldado por este proyecto Django.
4. Define la opción de configuración SITE_ID en cada uno de tus archivos de 
configuración (settings). Este valor debería ser el ID de base de datos del 
objeto Site para el sitio respaldado por el archivo de configuración.

Esta función de vista es reusable porque comprueba el sitio del artículo 
dinámicamente, según cuál sea el valor de la opción SITE_ID. 
Por ejemplo, digamos que el archivo de configuración de LJWorld.com tiene un 
SITE_ID asignado a 1, y que el de Lawrence.com lo tiene asignado a 2. Si esta vista es 
llamada cuando el archivo de configuración de LJWorld.com está activado, entonces 
la búsqueda de artículos se limita a aquellos en que la lista de sitios incluye 
LJWorld.com.

Flatpages

Usar Flatpages
 
Para instalar la aplicación flatpages, sigue estos pasos: 
1. Agrega 'django.contrib.flatpages' a tu INSTALLED_APPS. 
django.contrib.flatpages depende de django.contrib.sites, asi que asegúrate de 
que ambos paquetes se encuentren en INSTALLED_APPS. 
2. Agrega 'django.contrib.flatpages.middleware.FlatpageFallbackMiddleware' a 
tu variable de configuración MIDDLEWARE_CLASSES.
3. Ejecuta el comando python manage.py migrate para instalar las dos tablas 
necesarias en tu base de datos.

Examinemos cada uno de los campos: 

• url: La URL donde reside esta flatpage, excluyendo el nombre del dominio 
pero incluyendo la barra (/) inicial (por ej. /about/contact/). 
• title: El título de la flatpage. El framework no usa esto para nada en especial. 
Es tu responsabilidad visualizarlo en tu plantilla. 
• content: El contenido de la flatpage (por ej. el HTML de la página). El 
framework no usa esto para nada en especial. Es tu responsabilidad 
visualizarlo en tu plantilla. 
• enable_comments: Indica si deben activarse los comentarios e esta flatpage. 
El framework no usa esto para nada en especial. Puedes comprobar este valor 
en tu plantilla y mostrar un formulario de comentario si es necesario. 
• template_name: El nombre de la plantilla a usarse para renderizar esta 
flatpage. Es opcional; si no se indica o si esta plantilla no existe, el framework 
usará la plantilla flatpages/default.html. 
• registration_required: Indica si se requerirá registro para ver esta flatpage. 
Esto se integra con el framework de autenticación/usuarios de Django, el cual 
se trata en él capítulo 12. 
• sites: Los sitios en los cuales reside esta flatpage. Esto se integra con el 
framework sites de Django, el cual se trata en la sección ‘‘Sites’’ en este 
capítulo.

Puedes crear flatpages ya sea a través de la interfaz de administración de Django o 
a través de la API de base de datos de Django. Para más información, examina la 
sección ‘‘Agregando, modificando y eliminando flatpages’’.

Usar plantillas de flatpages

Es tu responsabilidad el crear la plantilla flatpages/default.html. En tu directorio 
de plantillas, crea un directorio flatpages que contenga un archivo default.html. 
A las plantillas de flatpages se les pasa una única variable de contexto: flatpage, la 
cual es el objeto flatpage.

Nota: Este middleware sólo se activa para errores 404 (página no encontrada) --- 
no para errores 500 (error en servidor) u otras respuestas de error. Nota también que 
el orden de MIDDLEWARE_CLASSES es relevante. Generalmente, puedes colocar el 
FlatpageFallbackMiddleware cerca o en el final de la lista, debido a que se trata de 
una opción de último recurso.

Agregar, modificar y eliminar flatpages 

Puedes agregar, cambiar y/o eliminar paginas estáticas o flatpages de dos maneras: 
1. A través de la interfaz de administración
 
Si has activado la interfaz automática de administración de Django, deberías 
ver una sección ‘‘Flatpages’’ en la página de índice de la aplicación admin. 
Edita las flatpages como lo harías con cualquier otro objeto en el sistema. 
2. A través de de la API Python
 
Redirects 

El framework redirects de Django te permite administrar las redirecciones con 
facilidad almacenándolos en una base de datos y tratándolos como cualquier otro 
objeto modelo de Django. Por ejemplo puedes usar el framework redirects para 
indicarle a Django ‘‘Redirecciona cualquier petición de /musica/ a 
/seccion/artista/musica/.’’. Esto es útil cuando necesitas cambiar las cosas de lugar 
en tu sitio; los desarrolladores Web deberían hacer lo que esté en sus manos para 
evitar los enlaces rotos.

Usando el framework redirects 

-> Para instalar la aplicación redirects, sigue estos pasos: 
-> Agrega 'django.contrib.redirects' a tu INSTALLED_APPS. 
-> Agrega 'django.contrib.redirects.middleware.RedirectFallbackMiddleware' a 
tu variable de configuración MIDDLEWARE_CLASSES. 
-> Ejecuta el comando python manage.py migrate para instalar la única tabla 
necesaria a tu base de datos.

manage.py migrate crea una tabla django_redirect en tu base de datos. Esta se 
trata sencillamente de una tabla de búsqueda con campos site_id, old_path y 
new_path.

Puedes crear redirecciones tanto a través de la interfaz de administración como a 
través de la API de base de datos de Django. Para más información puedes leer la 
sección ‘‘Agregar, modificar y eliminar redirecciones’’.

Luego entonces realiza los siguientes pasos: 

-> Si encuentra una coincidencia y new_path no está vacío, redirecciona la 
petición a new_path. 
-> Si encuentra una coincidencia y new_path está vació, envía una cabecera 
HTTP 410 (‘‘Ausente’’) y una respuesta vacía (sin contenido). 
-> Si no encuentra una coincidencia, el procesamiento de la petición continúa 
normalmente.

El middleware sólo se activa ante errores 404 --- no en errores 500 o respuestas con 
otros códigos de estado.
Nota: que el orden de MIDDLEWARE_CLASSES es relevante. Generalmente 
puedes colocar RedirectFallbackMiddleware cerca del final de la lista, debido a que 
se trata de una opción de último recurso.

Protección contra CSRF

En cualquier plantilla que use un formulario POST, usa la etiqueta csrf_token 
dentro de los elementos <form> si el formulario es para una URL interna. Por 
ejemplo: <form action="." method="post">{% csrf_token %}

Esto no se debe de hacer en formularios POST que apunten a URLs externas, ya 
que esto causaría que el CSRF sea escapado, conduciéndonos a problemas de 
vulnerabilidad.

En las vistas, solo asegúrate de que el procesador de contexto: 
django.core.context_processors.csrf sea usado. Usualmente puedes hacerlo de dos 
formas: 
1. Usando RequestContext, el cual siempre usa 
django.core.context_processors.csrf (no importando la configuración de 
TEMPLATE_CONTEXT_PROCESSORS). Si estas usando una vista genérica,response o 
una aplicación del paquete contrib, estas a salvo, ya que estas aplicaciones ya 
incluyen RequestContext por defecto.
2. Manualmente importa y usa el procesador generado por el token CSRF y 
agrégalo en el contexto de la plantilla.

Nota: si no se usa la capa de procesamiento de csrf, en su lugar puede usarse el decorador
csrf_protect

Humanizando Datos

El paquete contrib.humanize es una aplicación que aloja un conjunto de filtros de 
plantilla útiles a la hora de agregar un ‘‘toque humano’’ a los datos. Para activar esos 
filtros, agrega 'django.contrib.humanize' a tu variable de configuración 
INSTALLED_APPS. 
Una vez que has hecho eso, carga las etiquetas con {% load humanize %} en una 
plantilla, y tendrás acceso a los filtros que se describen en las siguientes secciones.

apnumber:
Para números entre 1 y 9, este filtro retorna la representación textual del número. 
Caso contrario retorna el numeral. Esto cumple con el estilo Associated Press. 
Ejemplos: 
-> 1 se convierte en uno. 
-> 2 se convierte en dos. 
-> 0 se convierte en 10. 
Puedes pasarle ya sea un entero o una representación en cadena de un entero.

intcomma:
Este filtro convierte un entero a una cadena conteniendo comas cada tres dígitos. 
Ejemplos: 
-> 4500 se convierte en 4,500. 
-> 45000 se convierte en 45,000.
-> 450000 se convierte en 450,000. 
-> 4500000 se convierte en 4,500,000.
Puedes pasarle ya sea un entero o una representación en cadena de un entero.

intword:
Este filtro convierte un entero grande a una representación amigable en texto. 
Funciona mejor con números mayores a un millón. 
Ejemplos: 
-> 1000000 se convierte en 1.0 millón. 
-> 1200000 se convierte en 1.2 millón. 
-> Se admiten valores hasta de 10^100 (Googol). 
Puedes pasarle ya sea un entero o una representación en cadena de un entero.

naturalday:
Este filtro se usa para mostrar fechas por ejemplo hoy, mañana o ayer. Tomando 
como valor la fecha del día de hoy. 
Ejemplos (cuando la etiqueta ‘now’ es 17 Feb 2007): 

-> 16 Feb 2007 se convierte en aller. 
-> 17 Feb 2007 se convierte en hoy. 
-> 18 Feb 2007 se convierte en mañana. 
Cualquier otro día se formatea según el argumento dado o configurado en 
DATE_FORMAT si no se da ningún argumento. 
Argumentos: Una fecha formateada como una cadena.

naturaltime 
Este filtro se usa para mostrar valores de tiempo, retorna una cadena que representa 
cuantos segundos, minutos y horas han pasado ---recurre al formato de la etiqueta 
timesince si el valor tiene más de un día. En este caso retorna el valor usando una 
frase. 
Ejemplo (cuando la etiqueta ‘now’ es 17 Feb 2007 16:30:00): 
-> 17 Feb 2007 16:30:00 se convierte en ahora. 
-> 17 Feb 2007 16:29:31 se convierte en hace 29 
-> 17 Feb 2007 16:29:00 se convierte en hace un minuto. 
-> 17 Feb 2007 16:25:35 se convierte en hace 4 minutos. 
->17 Feb 2007 15:30:29 se convierte en Hace 59 minutos.

ordinal 
 
Este filtro convierte un entero a una cadena cuyo valor es su ordinal. 
Ejemplos: 
-> 1 se convierte en 1st. 
-> 2 se convierte en 2nd.
-> 3 se convierte en 3rd.
Puedes pasarle ya sea un entero o una representación en cadena de un entero.


Cap_17. Middleware

(Nota: Aunque las cabeceras HTTP son llamadas X-Forwarded-For, Django hace 
que estén disponibles como request.META['HTTP_X_FORWARDED_FOR']. Con la 
excepción de content-length y content-type, cualquier cabecera HTTP en la petición 
es convertida en una clave request.META convirtiendo todos los caracteres a 
mayúsculas, remplazando cualquier guion con guiones bajos y agregando el prefijo 
HTTP_ al nombre.

Si el middleware está instalado (mira la siguiente sección), el valor de de todas las 
peticiones X-Forwarded-For será automáticamente insertado en 
request.META['REMOTE_ADDR']. Esto significa que tus aplicaciones Django no 
necesitan conocer si están detrás de un proxy de balanceo de carga o no, pueden 
simplemente acceder a request.META['REMOTE_ADDR'], y eso funcionará si se usa 
un proxy o no. 
De hecho, es una necesidad tan común, que esta pieza de middleware ya viene 
incorporada en Django. Está ubicada en django.middleware.http.

Instalación de Middleware

MIDDLEWARE = (
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
)
Nota: El orden es importante. En la fase de peticion y vista, Django aplica el middleware
en el orden de arriba hacia abajo y en la fase de respuesta y excepciones, en orden inverso

Métodos de un Middleware

Initializar: __init__(self):
Utiliza __init__() para realizar una configuración a nivel de sistema de una 
determinada clase middleware. 
Por razones de rendimiento, cada clase middleware activada es instanciada sólo 
una vez por proceso servidor. Esto significa que __init__() es llamada sólo una vez --- al 
iniciar el servidor, no para peticiones individuales. 
Una razón común para implementar un método __init__() es para verificar si el 
middleware es en realidad necesario. Si __init__() emite 
django.core.exceptions.MiddlewareNotUsed, entonces Django removerá el 
middleware de la pila de middleware. Tú podrías usar esta característica para 
verificar si existe una pieza de software que la clase middleware requiere, o verificar si 
el servidor esta ejecutándose en modo debug, o cualquier otra situación similar. 
Si una clase middleware define un método __init__(), éste no debe tomar 
argumentos más allá del estándar self.

Pre-procesador de petición: process_request(self, request):
Éste método es llamado tan pronto como la petición ha sido recibida --- antes de que 
Django haya analizado sintácticamente la URL para determinar cuál vista ejecutar. Si 
se le pasa el objeto HttpRequest, el cual puedes modificar a tu voluntad, 
process_request() debe retornar ya sea None o un objeto HttpResponse. 
 Si devuelve None, Django continuará procesando esta petición, ejecutando 
cualquier otro middleware y la vista apropiada. 
 Si devuelve un objeto HttpResponse, Django no se encargará de llamar a cualquier
otro middleware (de ningún tipo) o a la vista apropiada. Django inmediatamente 
devolverá ése objeto HttpResponse.

Pre-procesador de vista: process_view(self, request, view, args, 
kwargs):
Éste método es llamado después de la llamada al pre-procesador de petición y 
después de que Django haya determinado qué vista ejecutar, pero antes de que ésa 
vista sea realmente ejecutada.

Argumento                                Explicación 
request                                  El objeto HttpRequest. 
view                                     La función Python que Django llamará para manejar esta petición. Este 
                                         es en realidad el objeto función en sí, no el nombre de la función como 
                                         string. 

args                                     La lista de argumentos posicionales que serán pasados a la vista, no 
                                         incluye el argumento request (el cual es siempre el primer argumento 
                                         de una vista).

kwargs                                   El diccionario de palabras clave argumento que será pasado a la vista.


Pos-procesador de respuesta: process_response(self, request, 
response):
Éste método es llamado después de que la función de vista es llamada y la respuesta 
generada. Aquí, el procesador puede modificar el contenido de una respuesta; un caso de 
uso obvio es la compresión de contenido, como por ejemplo la compresión con gzip 
del HTML de la respuesta. Los parámetros deben ser bastante auto-explicativos: request es el objeto petición, 
y response es el objeto respuesta retornados por la vista. 
A diferencia de los pre-procesadores de petición y vista, los cuales pueden 
retornar None, process_response() debe retornar un objeto HttpResponse. Esa 
respuesta puede ser la respuesta original pasada a la función (posiblemente 
modificada) o una totalmente nueva.

Pos-procesador de excepción: process_exception(self, request, 
excepción):
Éste método es llamado sólo si ocurre algún error y la vista emite una excepción sin 
capturar. Puedes usar este método para enviar notificaciones de error, volcar información 
postmórtem a un registro, o incluso tratar de recuperarse del error automáticamente. 
Los parámetros para esta función son el mismo objeto request con el que hemos 
venido tratando hasta aquí, y excepción, el cual es el objeto Exception real emitido 
por la función de vista. process_exception() debe retornar ya sea None o un objeto HttpResponse. 
• Si devuelve None, Django continuará procesando esta petición con el 
manejador de excepción incorporado en el framework. 
• Si devuelve un objeto HttpResponse, Django usará esa respuesta en vez del 
manejador de excepción incorporado en el framework.

Middleware incorporado

Middleware de soporte para autenticación 
Clase middleware: django.contrib.auth.middleware.AuthenticationMiddleware.
Este middleware permite el soporte para autenticación. Agrega el atributo 
request.user, que representa el usuario actual registrado, a todo objeto HttpRequest 
que se recibe.

"Common” Middleware

Clase middleware: django.middleware.common.CommonMiddleware.
Este middleware agrega algunas conveniencias para los perfeccionistas: 
• Prohíbe el acceso a los agentes de usuario especificados en la configuración
DISALLOWED_USER_AGENTS: Si se especifica, esta configuración debería ser 
una lista de objetos de expresiones regulares compiladas que se comparan 
con el encabezado user-agent de cada petición que se recibe. Aquí está un 
pequeño ejemplo de un archivo de configuración:
import re
    DISALLOWED_USER_AGENTS = (
        re.compile(r'^OmniExplorer_Bot'),
        re.compile(r'^Googlebot') )

• Realiza re-escritura de URL basado en las configuraciones APPEND_SLASH y 
PREPEND_WWW: Si APPEND_SLASH es igual a True, las URLs que no poseen 
una barra al final serán redirigidas a la misma URL con una barra al final, a 
menos que el último componente en el path contenga un punto. De esta 
manera foo.com/bar es redirigido a foo.com/bar/, pero foo.com/bar/file.txt 
es pasado a través sin cambios.
Si PREPEND_WWW es igual a True, las URLs que no poseen el prefijo ‘‘www.’’ 
serán redirigidas a la misma URL con el prefijo ‘‘www.’’.
Ambas opciones tienen por objeto normalizar URLs. La filosofía es que cada 
URL debería existir en un --- y sólo un --- lugar. Técnicamente la URL 
example.com/bar es distinta de example.com/bar/, la cual a su vez es distinta 
de www.example.com/bar/. Un motor de búsqueda indexador trataría de 
forma separada estas URLs, lo cual es perjudicial para la valoración de tu sitio 
en el motor de búsqueda, por lo tanto es una buena práctica normalizar las 
URLs.

• Maneja ETags basado en la configuración USE_ETAGS: ETags es una 
optimización a nivel HTTP para almacenar condicionalmente las páginas en 
la caché. Si USE_ETAGS es igual a True, Django calculará una ETag para cada 
petición mediante la generación de un hash MD5 del contenido de la página, 
y se hará cargo de enviar respuestas Not Modified, si es apropiado.

Middleware de compresión

Clase middleware: django.middleware.gzip.GZipMiddleware.
Este middleware comprime automáticamente el contenido para aquellos 
navegadores que comprenden la compresión gzip (todos los navegadores modernos). 
Esto puede reducir mucho la cantidad de ancho de banda que consume un servidor 
Web. La desventaja es que esto toma un poco de tiempo de procesamiento para 
comprimir las páginas. 
Nosotros por lo general preferimos velocidad sobre ancho de banda, pero si tu 
prefieres lo contrario, solo habilita este middleware.

Middleware de GET condicional

Clase middleware: django.middleware.http.ConditionalGetMiddleware.
Este middleware provee soporte para operaciones GET condicionales. Si la 
respuesta contiene un encabezado Last-Modified o ETag, y la petición contiene
IfNone-Match o If-Modified-Since, la respuesta es reemplazada por una respuesta 304 
(‘‘Not modified’’). El soporte para ETag depende de la configuración USE_ETAGS y 
espera que el encabezado ETag de la respuesta ya este previamente fijado. Como se 
señaló anteriormente, el encabezado ETag es fijado por el middleware Common. 
También elimina el contenido de cualquier respuesta a una petición HEAD y fija 
los encabezados de respuesta Date y Content-Length para todas las peticiones.

Soporte para uso de proxy inverso (Middleware X-Forwarded-For) 
 
Clase middleware: django.middleware.http.SetRemoteAddrFromForwardedFor. 
Este es el ejemplo que examinamos en la sección anterior ‘‘Qué es middleware’’. 
Este establece el valor de request.META['REMOTE_ADDR'] basándose en el valor de 
request.META['HTTP_X_FORWARDED_FOR'], si este último está fijado. Esto es útil si 
estas parado detrás de un proxy inverso que provoca que cada petición 
REMOTE_ADDR sea fijada a 127.0.0.1.

Advertencia: Este middleware no permite validar HTTP_X_FORWARDED_FOR. 
Si no estás detrás de un proxy inverso que establece HTTP_X_FORWARDED_FOR 
automáticamente, no uses este middleware. Cualquiera puede inventar el valor de 
HTTP_X_FORWARDED_FOR, y ya que este establece REMOTE_ADDR basándose en 
HTTP_X_FORWARDED_FOR, significa que cualquiera puede falsear su dirección IP. 
Solo usa este middleware cuando confíes absolutamente en el valor de 
HTTP_X_FORWARDED_FOR.

Middleware de soporte para sesiones

Clase middleware: django.contrib.sessions.middleware.SessionMiddleware.
Este middleware habilita el soporte para sesiones. Mira el capítulo 14 para más 
detalles.

Middleware de cache de todo el sitio
 
Clase middleware: django.middleware.cache.CacheMiddleware.
Este middleware almacena en la cache cada página impulsada por Django. Este se 
analizó en detalle en el capítulo 15.

Middleware de transacción
 
Clase middleware: django.middleware.transaction.TransactionMiddleware.
Este middleware asocia un COMMIT o ROLLBACK de la base de datos con una 
fase de petición/respuesta. Si una vista de función se ejecuta con éxito, se emite un 
COMMIT. Si la vista provoca una excepción, se emite un ROLLBACK. 
El orden de este middleware en la pila es importante. Los módulos middleware 
que se ejecutan fuera de este, se ejecutan con commit-on-save --- el comportamiento 
por omisión de Django. Los módulos middleware que se ejecutan dentro de este 
(próximos al final de la pila) estarán bajo el mismo control de transacción que las 
vistas de función. 
Mira el Apéndice B para obtener más información sobre las transacciones de base 
de datos.

Middleware “X-View” 
 
Clase middleware: django.middleware.doc.XViewMiddleware.
Este middleware envía cabeceras HTTP X-View personalizadas a peticiones HEAD 
que provienen de direcciones IP definidas en la configuración INTERNAL_IPS. Esto 
es usado por el sistema automático de documentación de Django.


Cap_18. Integración con base de datos y aplicaciones existentes


Integración con una base de datos existente

La capa de base de datos de Django genera esquemas SQL desde código Python --- 
pero con una base de datos existente, tú ya tienes los esquemas SQL. En tal caso, 
necesitas crear modelos para tus tablas de la base de datos existente. Para este 
propósito, Django incluye una herramienta que puede generar el código del modelo 
leyendo el diseño de las tablas de la base de datos. Esta herramienta se llama 
inspectdb, y puedes llamarla ejecutando el comando manage.py inspectdb.

Usando inspectdb 
 
La utilidad inspectdb realiza una introspección de la base de datos a la que apunta tu 
archivo de configuración, determina una representación del modelo que usará 
Django para cada una de tus tablas, e imprime el código Python del modelo a la 
salida estándar. 
 Esta es una guía de un proceso típico de integración con una base de datos 
existente desde cero. Las únicas suposiciones son que Django está instalado y tienes 
una base de datos existente. 
1. Crea un proyecto Django ejecutando django-admin.py startproject mi_sitio 
(donde mi_sitio es el nombre de tu proyecto). Usaremos mi_sitio como el 
nombre de nuestro proyecto, en este ejemplo. 
2. Edita el archivo de configuración en ese proyecto, mi_sitio/settings.py, para 
decirle a Django cuáles son los parámetros de conexión a tu base de datos y 
cuál es su nombre. Específicamente, provee las configuraciones de 
DATABASE_NAME, DATABASE_ENGINE, DATABASE_USER, 
DATABASE_PASSWORD, DATABASE_HOST, y DATABASE_PORT. (Ten en 
cuenta que algunas de estas configuraciones son opcionales, ya que dependen 
de la base de datos a usar. Mira él capítulo 5 para más información).
3. Crea una aplicación dentro de tu proyecto ejecutando python 
mi_sitio/manage.py startapp myapp (donde myapp es el nombre de tu 
aplicación). Usaremos myapp como el nombre de aplicación aquí. 
4. Ejecuta el comando python mi_sitio/manage.py inspectdb. Esto examinará 
las tablas en la base de datos DATABASE_NAME e imprimirá para cada tabla 
el modelo de clase generado. Dale una mirada a la salida para tener una idea 
de lo que puede hacer inspectdb. 
5. Guarda la salida en el archivo models.py dentro de tu aplicación usando la 
redirección de salida estándar de la shell: 

python mi_sitio/manage.py inspectdb > mi_sitio/myapp/models.py

6. Edita el archivo mi_sitio/myapp/models.py para limpiar los modelos 
generados y realiza cualquier personalización necesaria. Te daremos algunas 
sugerencias para esto en la siguiente sección.

Limpiar los modelos generados

Como podrías esperar, la introspección de la base de datos no es perfecta, y 
necesitarás hacer una pequeña limpieza al código del modelo resultante. Aquí hay 
algunos apuntes para lidiar con los modelos generados: 
-> Cada tabla de la base de datos es convertida en una clase del modelo (es decir, 
hay un mapeo de uno-a-uno entre las tablas de la base de datos y las clases del 
modelo). Esto significa que tendrás que refactorizar los modelos para tablas 
con relaciones muchos-a-muchos en objetos ManyToManyField. 
-> Cada modelo generado tiene un atributo para cada campo, incluyendo 
campos de clave primaria id. Sin embargo, recuerda que Django agrega 
automáticamente un campo de clave primaria id si un modelo no tiene una 
clave primaria. Por lo tanto, es necesario remover cualquier línea que se 
parezca a ésta: 
       id = models.IntegerField(primary_key=True)
No solo estas líneas son redundantes, sino que pueden causar problemas si tu 
aplicación agregara nuevos registros a estas tablas. El comando inspectdb no 
puede detectar si un campo es autoincrementado, así que está en tí cambiar 
esto a AutoField, si es necesario.
-> Cada tipo de campo (ej., CharField, DateField) es determinado mirando el 
tipo de la columna de la base de datos (ej., VARCHAR, DATE). Si inspectdb no 
puede mapear un tipo de columna a un tipo de campo del modelo, usará 
TextField e insertará el comentario Python 'This field type is a guess.' a 
continuación del campo en el modelo generado. Mantén un ojo en eso, y 
cambia el tipo de campo adecuadamente si es necesario. 
Si un campo en tu base de datos no tiene un buen equivalente en Django, con 
seguridad puedes dejarlo fuera. La capa de modelo de Django no requiere que 
incluyas todos los campos de tu(s) tabla(s).
-> Si un nombre de columna de tu base de datos es una palabra reservada de 
Python (como pass, class o for), inspectdb agregará '_field' al nombre del
atributo y establecerá el atributo db_column al nombre real del campo (ej., 
pass, class, o for). 
Por ejemplo, si una tabla tiene una columna INT llamada for, el modelo 
generado tendrá un campo como este: 
for_field = models.IntegerField(db_column='for')
 inspectdb insertará el comentario Python 'Field renamed because it was a 
Python reserved word.' a continuación del campo.
-> Si tu base de datos contiene tablas que hacen referencia a otras tablas (como 
la mayoría de las bases de datos lo hacen), tal vez tengas que re-acomodar el 
orden de los modelos generados, de manera que los modelos que hacen 
referencia a otros modelos estén ordenados apropiadamente. Por ejemplo, si 
un modelo Libro tiene una ForeignKey al modelo Autor, el modelo Autor debe 
ser definido antes del modelo Libro. Si necesitas crear una relación en un 
modelo que todavía no está definido, puedes usar el nombre del modelo, en 
vez del objeto modelo en sí. 
-> inspectdb detecta claves primarias para PostgreSQL, MySQL y SQLite. Es 
decir, inserta primary_key=True donde sea necesario. Para otras bases de 
datos, necesitarás insertar primary_key=True para al menos un campo en 
cada modelo, ya que los modelos Django requieren tener un campo 
primary_key=True. 
-> La detección de claves foráneas sólo funciona con PostgreSQL y con ciertos 
tipos de tablas MySQL. En otros casos, los campos de clave foránea serán 
generados como campos IntegerField, asumiendo que la columna de clave 
foránea fue una columna INT.

Integración con un sistema de autentificación

Especificar los back-ends de autentificación
Ejemplo:
from django.conf import settings
from django.contrib.auth.models import User, check_password
class SettingsBackend(object):
    """
    Autentificación contra la configuración ADMIN_LOGIN y ADMIN_PASSWORD.
    Usa el nombre de login, y el hash del password. Por ejemplo:
    ADMIN_LOGIN = ’admin’
    ADMIN_PASSWORD =     
        ’sha1$4e987$afbcf42e21bd417fb71db8c66b321e9fc33051de’
    """
    def authenticate(self, username=None, password=None):
        login_valid = (settings.ADMIN_LOGIN == username)
        pwd_valid = check_password(password, settings.ADMIN_PASSWORD)
        if login_valid and pwd_valid:
            try:
               user = User.objects.get(username=username)
            except User.DoesNotExist:
                # Crea un nuevo usuario. Nota que podemos fijar un password
                # para cualquiera, porque este no será comprobado; el password
                # de settings.py lo hará.
                user = User(username=username, password=’get from settings.py’)
                user.is_staff = True
                user.is_superuser = True
                user.save()
            return user
        return None

    def get_user(self, user_id):
        try:
           return User.objects.get(pk=user_id)
        except User.DoesNotExist:
            return None


Integración con aplicaciones web existentes

La clave está en que Django será activado para un patrón particular de URL sólo si 
tu archivo httpd.conf lo dice. El despliegue por omisión explicado en el capítulo 12, 
asume que quieres que Django impulse todas las páginas en un dominio particular
<Location "/">
    SetHandler python­program
    PythonHandler django.core.handlers.modpython
    SetEnv DJANGO_SETTINGS_MODULE mi_sitio.settings
    PythonDebug On
</Location>

Aquí, la línea <Location "/"> significa ‘‘maneja cada URL, comenzando en la raíz’’, 
con Django. 
Esta perfectamente bien limitar esta directiva <Location> a cierto árbol de 
directorio. Por ejemplo, digamos que tienes una aplicación PHP existente que 
impulsa la mayoría de las páginas en un dominio y quieres instalar el sitio de 
administración de Django en /admin/ sin afectar el código PHP. Para hacer esto, sólo 
configura la directiva <Location> a /admin/:
<Location "/admin/">
    SetHandler python­program
    PythonHandler django.core.handlers.modpython
    SetEnv DJANGO_SETTINGS_MODULE mi_sitio.settings
    PythonDebug On
</Location>



Cap_19. Internacionalización

Encontrarás a menudo ‘‘internacionalización’’ abreviada 
como I18N (el número 18 se refiere al número de letras omitidas entre la ‘‘I’’ inicial y 
la ‘‘N’’ final).
Encontrarás a menudo ‘‘localización’’ abreviada como L10N.

Django en si está totalmente internacionalizado; todas las cadenas están marcadas 
para su traducción y existen variables de configuración que controlan la visualización 
de valores locales dependientes como fechas y horarios. Django también incluye más 
de 40 archivos de localización. Si no hablas inglés en forma nativa, existe una buena 
probabilidad de que Django ya se encuentre traducido a tu idioma nativo.

SI NO NECESITAS USAR INTERNACIONALIZACIÓN 
Los ganchos de internacionalización de Django se encuentran activos por omisión, lo 
cual incurre en una pequeña sobrecarga. Si no utilizas la internacionalización, 
deberías establecer USE_I18N = False en tu archivo de configuración. Si USE_I18N 
tiene el valor False Django implementará algunas optimizaciones de manera de no 
cargar la maquinaria de localización. 
Probablemente querrás también eliminar django.core.context_processors.i18n de tu 
variable de configuración TEMPLATE_CONTEXT_PROCESSORS.

Los tres pasos para usar la internacionalización en aplicaciones Django son: 
1. Especifica las cadenas de traducción en el código Python y en las plantillas. 
2. Implementa las traducciónes para esas cadenas, en cualquiera de los 
lenguajes que quieras soportar. 
3. Activa el middleware local en la configuración de Django. 
Cubriremos cada uno de estos pasos detalladamente.

Ejemplos:
La función django.utils.translation.gettext() es idéntica a _(). Este ejemplo es 
idéntico al anterior:
from django.utils.translation import ugettext
def mi_vista(request):
    salida = ugettext("Bienvenido a mi sitio.")
    return HttpResponse(salida)

La traducción funciona también sobre valores computados. Este ejemplo es 
idéntico a los dos anteriores: 
def mi_vista(request):
    palabras = [’Bienvenido’, ’a’, ’mi’, ’sitio.’]
    salida = _(’ ’.join(palabras))
    return HttpResponse(salida)

Las cadenas que le pasas a _() o ugettext() pueden contener marcadores de 
posición especificados con la sintaxis estándar de interpolación de cadenas de 
Python con nombres, por ejemplo: 
def mi_vista(request, m, d):
    salida = _(’Hoy es %(mes)s %(dia)s.’) % {’mes’: m, ’dia’: d}
    return HttpResponse(salida)

Comentarios para traducciónes

Si te gustaría darle indicios a los traductores acerca de una cadena traducible, puedes 
añadir un comentario, usando un prefijo con la palabra clave Translators en la línea 
anterior a la cadena, por ejemplo: 
def mi_vista(request):
    # Translators: Este mensaje aparece en la página de inicio únicamente.
    output = ugettext("Bienvenidos a mi sitio.")

Esto también funciona en plantillas. Así como en el código Python, las notas para 
traductores pueden especificarse usando comentarios en las plantillas de la siguiente 
forma. 
{% comment %}   Translators: Verbo de la vista {% endcomment %}
{% translate "Vista" %}
{% comment %}Translators: Introducción corta sobre publicidad{% endcomment %}
     <p>{% blocktranslate %}Traducir varias líneas de forma literal.{% endblocktranslate %}</p>
 o con etiquetas {# ... #} uno por línea, para construir comentarios: 
{# Translators: Etiqueta de un botón de búsqueda #}
<button type="submit">{% translate "Ir" %}</button>
{# Translators: Éste es texto de la plantilla base #}
{% blocktranslate %}Bloque ambiguo de texto traducible{% endblocktranslate %}

Marcando cadenas como no-op

Nota: Todas las funciones de traduccion estan en el modulo django.utils.translation

Usar la funcion django.utils.translation.gettext_noop() para marcar string como
string para ser traducidos pero sin traducirlos.

Usa este enfoque si deseas tener cadenas constantes que deben ser almacenadas 
en el idioma original --- tales como cadenas en una base de datos, pero que deben ser 
traducidas en el último momento posible, por ejemplo cuando la cadena es 
presentada al usuario.

Traducción perezosa

Usa siempre traducciónes perezosas en modelos Django (de lo contrario no serán 
traducidos correctamente para cada usuario). Y es una buena idea agregar también 
traducciónes de los nombres de campos y nombres de tablas.Esto significa que 
también puedes especificar las opciones verbose_name y verbose_name_plural como 
traducibles en forma explícita en la clase Meta.

Pluralización

Usar la funcion django.utils.translation.ngettext() para especificar mensajes pluralizados.
La funcion toma 3 argumentos: el string en singular, el string en plural, y  el numero de objetos.
Ejemplo: 
text = ngettext(
    'There is %(count)d %(name)s object available.', 'There are %(count)d %(name)s objects available.',
    count,
) % {'count': count,'name': Report._meta.verbose_name,}


Cadenas de traducción en plantillas

Las traducciónes en las plantillas de Django usan dos etiquetas de plantilla y una 
sintaxis ligeramente diferente a la del código Python. Para que tus plantillas puedan 
acceder a esas etiquetas coloca {% load i18n %} al principio de tu plantilla. 
La etiqueta de plantilla {% translate %} marcan una cadena para su traducción, 
(encerradas por comillas simples o dobles) o el contenido de una variable.

Si la opción noop está presente, las operaciones de búsqueda de variables todavía 
ocurre, pero se salta la traducción. Esto es útil cuando el contenido ‘‘de fuera’’ 
requiere la traducción en el futuro.

No es posible mezclar en las plantillas variables dentro de cadenas con la etiqueta 
{% translate %}. Si tu traducción requiere variables (marcadores de posición) puedes 
usar por ejemplo {% blocktranslate %}.

Para traducir una expresión de plantilla --- por ejemplo, usando filtros de plantillas 
--- necesitas asociar la expresión a una variable local que será la que se usará dentro 
del bloque de traducción:
{% blocktranslate with valor|filter as variable %}
    Esta tiene una {{ variable }} dentro.
{% endblocktranslate %}

Si necesitas asociar más de una expresión dentro de una etiqueta blocktrans, 
separa las partes con and: 
{% blocktranslate with libro|titulo as mi_libro and autor|titulo as mi_autor %}
    Este es {{ mi_libro }} por {{ mi_autor}}
{% endblocktranslate %}

Para pluralizar, especifica tanto la forma singular como la plural con la etiqueta {% 
plural %} la cual aparece dentro de {% blocktrans %} y {% endblocktrans %}, por 
ejemplo: 
{% blocktranslate count list|length as counter %}
       Hay únicamente {{ nombre }} objeto.
{% plural %}
    Hay  {{ counter }} {{ nombre }} objetos.
{% endblocktranslate %}

Cuando usas RequestContext , tus plantillas tienen acceso a tres variables 
específicas relacionadas con la traducción: 
• {{ LANGUAGES }} es una lista de tuplas en las cuales el primer elemento es el 
código de idioma y el segundo es el nombre y escrito usando el mismo). 
• {{ LANGUAGE_CODE }} es el idioma preferido del usuario actual, expresado 
como una cadena (por ejemplo en-us). (Consulta la sección ‘‘3. Cómo 
descubre Django la preferencia de idioma’’ para información adicional). 
• {{ LANGUAGE_BIDI }} es el sistema de escritura del idioma actual. Si el valor 
es True, se trata de un idioma derecha-a-izquierda (por ejemplo hebreo, 
árabe). Si el valor es False, se trata de de un idioma izquierda-a-derecha (por 
ejemplo inglés, francés, alemán). 
Si no usas la extensión RequestContext, puedes usar estos valores, con estas 
tres etiquetas de plantilla: 
{% get_current_language as LANGUAGE_CODE %}
{% get_available_languages as LANGUAGES %}
{% get_current_language_bidi as LANGUAGE_BIDI %}

Trabajando con objetos en traducción perezosas 
 
El uso de ugettext_lazy() y ungettext_lazy() para marcar cadenas en modelos y 
funciones de utilidad general es una operación muy común, Cuando trabajamos con 
estos objetos en cualquier parte de nuestro código, debemos asegurarnos de no 
convertir nuestro código accidentalmente en cadenas, para ello necesitamos 
asegurarnos de convertir las cadenas lo más tarde posible (de modo que la traducción 
correcta surta efecto). Esto hace necesario el uso de unas par de funciones de ayuda.

Juntando cadenas con: string_concat()
 
El método estándar de Python join, usado para juntar cadenas (''.join([...])) no trabaja 
en listas que contienen traducciónes perezosas. En su lugar debes usar 
django.utils.translation.string_concat(), el cual crea un objeto perezoso que 
concatena el contenido y convierte las cadenas únicamente cuando el resultado es 
incluido en la cadena.
Por ejemplo: 
from django.utils.translation import string_concat
# ...
nombre = ugettext_lazy(u’John Lennon’)
instrumento = ugettext_lazy(u’guitarra’)
resultado = string_concat([nombre, ’: ’, instrumento])

En este caso, la traducción perezosa en la variable resultado únicamente convierte 
la cadena cuando resultado es usado en una cadena (usualmente cuando se 
renderiza la plantilla)

El decorador allow_lazy()

Si escribes tus propias funciones y te ocupas de las traducciónes, lo más seguro es 
que te has encontrado con este problema, ¿Qué hacer cuando el primer argumento es 
un objeto perezoso de una traducción? Si necesitas convertirlo a una cadena 
inmediatamente, porque tal vez necesites usarlo fuera de una función de vista (y por 
lo tanto la configuración actual no funciona).

Como crear archivos de idioma

Una vez que hayas etiquetado tus cadenas para su posterior traducción, necesitas 
escribir (u obtener) las traducciónes propiamente dichas. En esta sección 
explicaremos como es que eso funciona.

Creando los archivos de mensajes

Para crear o actualizar un archivo de mensajes, ejecuta este comando: 
-> django-admin makemessages -l de 

Donde de "es" el código de idioma para el archivo de mensajes que deseas crear. El 
código de idioma en este caso está en formato locale. Por ejemplo, el mismo es pt_BR 
para portugués de Brasil y de_AT para alemán de Austria. Echa un vistazo a los 
códigos de idioma en el directorio django/conf/locale/ para ver cuáles son los 
idiomas actualmente incluidos.
El script debe ser ejecutado desde una de tres ubicaciones: 
-> El directorio raíz de tu proyecto Django. 
-> El directorio raíz de tu aplicación Django. 
-> El directorio raíz django (no una copia de git, sino el que se halla referenciado 
por $PYTHONPATH o que se encuentra en algún punto debajo de esa ruta. 
Este es únicamente relevante si estas creando una traducción para Django 
mismo.

El script recorre completamente el árbol en el cual es ejecutado y extrae todas las 
cadenas marcadas para traducción. Crea (o actualiza) un archivo de mensajes en el 
directorio locale/LANG/LC_MESSAGES. En el ejemplo de, el archivo será 
locale/de/LC_MESSAGES/django.po.

Por defecto django-admin.py makemessages examina cada archivo que tenga una 
extensión .html. En el caso de que quieras sobrescribirá el valor por default usa la 
opción --extension o -e para especificar la extensión del archivo a examinar:
django-­admin.py makemessages ­-l de ­-e txt

Separa múltiples extensiones con comas y/o usa -e o --extensión varias veces: 
django-­admin.py makemessages ­-l de ­-e html,txt ­e xml

Es necesaria una rápida explicación: 
-> msgid es la cadena de traducción, la cual aparece en el código fuente. No la 
modifiques. 
-> msgstr es donde colocas la traducción específica a un idioma. Su valor inicial 
es vacío de manera que es tu responsabilidad el cambiar esto. Asegúrate de 
mantener las comillas alrededor de tu traducción.
-> Por conveniencia, cada mensaje incluye el nombre del archivo y el número de 
línea desde el cual la cadena de traducción fue extraída.

Los mensajes largos son un caso especial. La primera cadena inmediatamente a 
continuación de msgstr (o msgid) es una cadena vacía. El contenido en si mismo se 
encontrará en las próximas líneas con el formato de una cadena por línea. Dichas 
cadenas se concatenan en forma directa. ¡No olvides los espacios al final de las 
cadenas; en caso contrario todas serán agrupadas sin espacios entre las mismas!

TEN EN CUENTA EL CONJUNTO DE CARACTERES
Cuando crees un archivo .po con tu editor de texto favorito, primero edita la línea del 
conjunto de caracteres (busca por el texto "CHARSET") y fija su valor al del conjunto 
de caracteres usarás para editar el contenido. Generalmente, UTF-8 debería 
funcionar para la mayoría de los idiomas pero gettext debería poder manejar 
cualquier conjunto de caracteres. 
 Para reexaminar todo el código fuente y las plantillas en búsqueda de nuevas 
cadenas de traducción y actualizar todos los archivos de mensajes para todos los 
idiomas, ejecuta lo siguiente: 
      django­-admin.py makemessages –a

Compilando archivos de mensajes

En el mismo directorio desde el cual ejecutaste django-admin.py makemessages, ejecuta 
django­admin.py compilemessages de la siguiente manera:
-> django­-admin.py compilemessages

Nota: Si defines un LANGUAGES personalizado es posible marcar los idiomas como 
cadenas de traducción --- pero usa una función gettext() ‘‘boba’’, no la que se 
encuentra en django.utils.translation. Nunca debes importar django.utils.translation 
desde el archivo de configuración debido a que ese módulo a su vez depende de las 
variables de configuración, y eso crearía una importación circular. 
 La solución es usar una función gettext()` ‘‘boba’’. A continuación un archivo de 
configuración de ejemplo: 
ugettext = lambda s: s
LANGUAGES = (
    (’de’, ugettext(’German’)),
    (’en’, ugettext(’English’)),
)

La vista de redirección set_language

Por conveniencia, Django incluye una vista django.views.i18n.set_language, que fija 
la preferencia de idioma de un usuario y redirecciona de vuelta a la página previa. 
Activa esta vista agregando la siguiente línea a tu URLconf: 
url(r’^i18n/’, include(’django.conf.urls.i18n’)),

Observa que este ejemplo hace que la vista esté disponible en /i18n/setlang/. 
La vista espera ser llamada vía el método POST, con un parámetro language incluido 
en la cadena de petición. Si el soporte para sesiones está activo, la vista guarda la 
opción de idioma en la sesión del usuario. En caso contrario, guarda el idioma en una 
cookie django_language.

Traducciónes y JavaScript

La vista javascript_catalog

La solución principal a esos problemas es la vista javascript_catalog, que genera una 
biblioteca de código JavaScript con funciones que emulan la interfaz gettext más un 
arreglo de cadenas de traducción. Dichas cadenas de traducción se toman desde la 
aplicación, el proyecto o el núcleo de Django, de acuerdo a lo que especifiques ya sea 
en el diccionario info_dict o en la URL. 

Para usar el catalogo de javascript cargar la fuente:
<script src="{% url 'javascript-catalog' %}"></script>

Esto hace uso de un lazo en reversa para encontrar la URL de javascript. Cuando es cargado el 
catalogo, js tiene acceso a :
-> gettext
-> ngettext
-> interpolate
-> get_format
-> gettext_noop
-> pgettext
-> npgettext
-> pluralidx

Creando catálogos de traducciónes JavaScript

Los catálogos de traducciónes se crean y actualizan de la misma manera que el resto 
de los catálogos de traducciónes de Django, con la herramienta django-admin.py 
makemessages. La única diferencia es que es necesario que proveas un parámetro -d 
djangojs, de la siguiente forma: 
django-­admin.py makemessages ­-d djangojs -­l de

Esto crea o actualiza el catálogo de traducción para JavaScript para alemán. Luego 
de haber actualizado catálogos, sólo ejecuta django-admin.py compilemessages de la 
misma manera que lo haces con los catálogos de traducción normales de Django.


Cap_20. seguridad

Nunca -- bajo ninguna circunstancia -- confíes en datos enviados por un navegador.
